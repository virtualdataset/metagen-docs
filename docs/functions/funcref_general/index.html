<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>general - VirtualDataSet</title>
    <meta name="generator" content="Hugo 0.31" />

    
    <meta name="description" content="VirtualDataSet Docs">
    
    <link rel="canonical" href="http://docs.virtdata.io/functions/funcref_general/">
    

    <meta property="og:url" content="http://docs.virtdata.io/functions/funcref_general/">
    <meta property="og:title" content="VirtualDataSet">
    <meta property="og:image" content="/images/virtdata_128.png">
    <meta name="apple-mobile-web-app-title" content="VirtualDataSet">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="http://docs.virtdata.io/images/engineblock_32.png">
    <link rel="icon" type="image/x-icon" href="http://docs.virtdata.io/images/engineblock_32.png">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('/fonts/icon.eot?52m981');
        src: url('/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
             url('/fonts/icon.woff?52m981')
               format('woff'),
             url('/fonts/icon.ttf?52m981')
               format('truetype'),
             url('/fonts/icon.svg?52m981#icon')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/application.css">
    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/temporary.css">
    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/palettes.css">
    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/images.css">

    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:400,700|Roboto&#43;Mono">
    <style>
      body, input {
        font-family: 'Roboto', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Roboto Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="http://docs.virtdata.io/javascripts/modernizr.js"></script>

    

  
    

    

    
    

    
    

    
    

    
    

    
    

    
    

    
    
    
    
    

    
    


  </head>
  <body class="palette-primary-grey palette-accent-teal">




<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        general
      </div>
    </div>

    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/virtualdataset/metagen-java" title="@virtualdataset/metagen-java on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="http://docs.virtdata.io/" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="http://docs.virtdata.io/images/virtdata_128.png">
        </div>
      
      <div class="name">
        <strong>VirtualDataSet </strong>
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      

      <div class="toc">
        
        <ul>
          




<li>
  
    <span class="section">Introduction</span>
    <ul>
      
        
        



<a  title="Why VirtData?" href="http://docs.virtdata.io/why_virtdata/why_virtdata/">
	
	Why VirtData?
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Concepts</span>
    <ul>
      
        
        



<a  title="Mapping Functions" href="http://docs.virtdata.io/concepts/mapping_functions/">
	
	Mapping Functions
</a>



      
        
        



<a  title="Function Graphs" href="http://docs.virtdata.io/concepts/function_graphs/">
	
	Function Graphs
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Modeling Datasets</span>
    <ul>
      
        
        



<a  title="Cardinality" href="http://docs.virtdata.io/modeling_datasets/modeling_cardinality/">
	
	Cardinality
</a>



      
        
        



<a  title="Set Relationships" href="http://docs.virtdata.io/modeling_datasets/set_relationships/">
	
	Set Relationships
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Syntax Reference</span>
    <ul>
      
        
        



<a  title="Syntax Reference" href="http://docs.virtdata.io/syntax/syntax_overview/">
	
	Syntax Reference
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Function Reference</span>
    <ul>
      
        
        



<a  title="collections" href="http://docs.virtdata.io/functions/funcref_collections/">
	
	collections
</a>



      
        
        



<a  title="conversion" href="http://docs.virtdata.io/functions/funcref_conversion/">
	
	conversion
</a>



      
        
        



<a  title="datetime" href="http://docs.virtdata.io/functions/funcref_datetime/">
	
	datetime
</a>



      
        
        



<a  title="diagnostics" href="http://docs.virtdata.io/functions/funcref_diagnostics/">
	
	diagnostics
</a>



      
        
        



<a  title="distributions" href="http://docs.virtdata.io/functions/funcref_distributions/">
	
	distributions
</a>



      
        
        



<a  title="general" href="http://docs.virtdata.io/functions/funcref_general/">
	
	general
</a>



      
        
        



<a  title="premade" href="http://docs.virtdata.io/functions/funcref_premade/">
	
	premade
</a>



      
        
        



<a  title="state" href="http://docs.virtdata.io/functions/funcref_state/">
	
	state
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Site Info</span>
    <ul>
      
        
        



<a  title="Typography" href="http://docs.virtdata.io/siteinfo/typography/">
	
	Typography
</a>



      
    </ul>
  
</li>


        </ul>
        

        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1>general </h1>

			

<h2 id="add">Add</h2>

<p>Adds a value to the input.</p>

<ul>
<li>double -&gt; Add(double: addend) -&gt; double</li>
<li>long -&gt; Add(long: addend) -&gt; int</li>
<li>long -&gt; Add(long: addend) -&gt; long</li>
<li>int -&gt; Add(int: addend) -&gt; int

<ul>
<li><em>ex:</em> <code>Add(23)</code> - <em>adds integer 23 to the input integer value</em></li>
</ul></li>
</ul>

<h2 id="addcyclerange">AddCycleRange</h2>

<p>Adds a cycle range to the input, producing an increasing sawtooth-like output.</p>

<ul>
<li>long -&gt; AddCycleRange(long: maxValue) -&gt; int</li>
<li>long -&gt; AddCycleRange(long: minValue, long: maxValue) -&gt; int</li>
<li>long -&gt; AddCycleRange(long: maxValue) -&gt; long</li>
<li>long -&gt; AddCycleRange(long: minValue, long: maxValue) -&gt; long</li>
<li>int -&gt; AddCycleRange(int: maxValue) -&gt; int</li>
<li>int -&gt; AddCycleRange(int: minValue, int: maxValue) -&gt; int</li>
</ul>

<h2 id="addhashrange">AddHashRange</h2>

<p>Adds a pseudo-random value within the specified range to the input.</p>

<ul>
<li>long -&gt; AddHashRange(long: maxValue) -&gt; int</li>
<li>long -&gt; AddHashRange(long: minValue, long: maxValue) -&gt; int</li>
<li>long -&gt; AddHashRange(long: maxValue) -&gt; long</li>
<li>long -&gt; AddHashRange(long: minValue, long: maxValue) -&gt; long</li>
<li>int -&gt; AddHashRange(int: maxValue) -&gt; int</li>
<li>int -&gt; AddHashRange(int: minValue, int: maxValue) -&gt; int</li>
</ul>

<h2 id="alphanumericstring">AlphaNumericString</h2>

<p>Create an alpha-numeric string of the specified length, character-by-character.</p>

<ul>
<li>long -&gt; AlphaNumericString(int: length) -&gt; String</li>
</ul>

<h2 id="beta">Beta</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Beta_distribution">Wikipedia: Beta distribution</a></p>

<p>@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/BetaDistribution.html">Commons JavaDoc: BetaDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Beta(double: alpha, double: beta, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Beta(double: alpha, double: beta, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="binomial">Binomial</h2>

<p>@see <a href="http://en.wikipedia.org/wiki/Binomial_distribution">Wikipedia: Binomial distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/BinomialDistribution.html">Commons JavaDoc: BinomialDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function based on inverse cumulative
 density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Binomial(int: trials, double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Binomial(int: trials, double: p, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Binomial(int: trials, double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Binomial(int: trials, double: p, String[]&hellip;: modslist) -&gt; long</li>
</ul>

<h2 id="cauchy">Cauchy</h2>

<p>@see <a href="http://en.wikipedia.org/wiki/Cauchy_distribution">Wikipedia: Cauchy_distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/CauchyDistribution.html">Commons Javadoc: CauchyDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Cauchy(double: median, double: scale, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Cauchy(double: median, double: scale, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="chisquared">ChiSquared</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Chi-squared_distribution">Wikipedia: Chi-squared distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ChiSquaredDistribution.html">Commons JavaDoc: ChiSquaredDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; ChiSquared(double: degreesOfFreedom, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; ChiSquared(double: degreesOfFreedom, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="clear">Clear</h2>

<p>Clears the per-thread map which is used by the Expr function.</p>

<ul>
<li>long -&gt; Clear() -&gt; long

<ul>
<li><em>notes:</em> Clear all named entries from the per-thread map.</li>
<li><em>ex:</em> <code>Clear()</code> - <em>clear all thread-local variables</em></li>
</ul></li>
<li>long -&gt; Clear(String[]&hellip;: names) -&gt; long

<ul>
<li><em>notes:</em> Clear the specified names from the per-thread map.</li>
<li><em>ex:</em> <code>Clear('foo')</code> - <em>clear the thread-local variable &lsquo;foo&rsquo;</em></li>
<li><em>ex:</em> <code>Clear('foo','bar')</code> - <em>clear the thread-local variables &lsquo;foo&rsquo; and &lsquo;bar&rsquo;</em></li>
</ul></li>
</ul>

<h2 id="combinations">Combinations</h2>

<p>Convert a numeric value into a code according to ASCII printable
characters. This is useful for creating various encodings using different
character ranges, etc.</p>

<p>This mapper can map over the sequences of character ranges providing every unique
combination and then wrapping around to the beginning again.
It can convert between character bases with independent radix in each position.
Each position in the final string takes its values from a position-specific
character set, described by the shorthand in the examples below.</p>

<p>The constructor will throw an error if the number of combinations exceeds that
which can be represented in a long value. (This is a very high number).</p>

<ul>
<li>long -&gt; Combinations(String: spec) -&gt; String

<ul>
<li><em>ex:</em> <code>Combinations('A-Z;A-Z')</code> - <em>a two digit alphanumeric code. Wraps at 26^2</em></li>
<li><em>ex:</em> <code>Combinations('0-9A-F')</code> - <em>a single hexadecimal digit</em></li>
<li><em>ex:</em> <code>Combinations('0123456789ABCDEF')</code> - <em>a single hexadecimal digit</em></li>
<li><em>ex:</em> <code>Combinations('0-9A-F;0-9A-F;0-9A-F;0-9A-F;')</code> - <em>two bytes of hexadecimal</em></li>
<li><em>ex:</em> <code>Combinations('A-9')</code> - <em>upper case alphanumeric</em></li>
</ul></li>
</ul>

<h2 id="constantcontinuous">ConstantContinuous</h2>

<p>Always yields the same value
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ConstantContinuousDistribution.html">Commons JavaDoc: ConstantContinuousDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; ConstantContinuous(double: value, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; ConstantContinuous(double: value, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="cyclerange">CycleRange</h2>

<p>Yields a value within a specified range, which rolls over continuously.</p>

<ul>
<li>long -&gt; CycleRange(long: maxValue) -&gt; int</li>
<li>long -&gt; CycleRange(long: minValue, long: maxValue) -&gt; int</li>
<li>long -&gt; CycleRange(long: maxValue) -&gt; long</li>
<li>long -&gt; CycleRange(long: minValue, long: maxValue) -&gt; long</li>
<li>int -&gt; CycleRange(int: maxValue) -&gt; int

<ul>
<li><em>notes:</em> Sets the maximum value of the cycle range. The minimum is default to 0.</li>
<li><em>ex:</em> <code>CycleRange(34)</code> - <em>add a rotating value between 0 and 34 to the input</em></li>
</ul></li>
<li>int -&gt; CycleRange(int: minValue, int: maxValue) -&gt; int

<ul>
<li><em>notes:</em> Sets the minimum and maximum value of the cycle range.</li>
</ul></li>
</ul>

<h2 id="directorylines">DirectoryLines</h2>

<p>Read each line in each matching file in a directory structure, providing one
line for each time this function is called. The files are sorted at the time
the function is initialized, and each line is read in order.</p>

<p>This function does not produce the same result per cycle value. It is possible
that different cycle inputs will return different inputs if the cycles are not
applied in strict order. Still, this function is useful for consuming input
from a set of files as input to a test or simulation.</p>

<ul>
<li>long -&gt; DirectoryLines(String: basepath, String: namePattern) -&gt; String

<ul>
<li><em>ex:</em> <code>DirectoryLines('/var/tmp/bardata', '.*')</code> - <em>load every line from every file in /var/tmp/bardata</em></li>
</ul></li>
</ul>

<h2 id="div">Div</h2>

<p>Divide the operand by a fixed value and return the result.</p>

<ul>
<li>double -&gt; Div(double: divisor) -&gt; double</li>
<li>long -&gt; Div(int: divisor) -&gt; int</li>
<li>long -&gt; Div(long: divisor) -&gt; long

<ul>
<li><em>ex:</em> <code>Div(42L)</code> - <em>divide all inputs by 42L</em></li>
</ul></li>
<li>int -&gt; Div(int: divisor) -&gt; int</li>
</ul>

<h2 id="dividetolongtostring">DivideToLongToString</h2>

<p>This is equivalent to <code>Div(...)</code>, but returns
the result after String.valueOf(&hellip;). This function is also deprecated,
as it is easily replaced by other functions.</p>

<ul>
<li>long -&gt; DivideToLongToString(long: divisor) -&gt; String</li>
</ul>

<h2 id="doubletofloat">DoubleToFloat</h2>

<p>Convert the input double value to the closest float value.</p>

<ul>
<li>double -&gt; DoubleToFloat() -&gt; Float</li>
</ul>

<h2 id="enumerated">Enumerated</h2>

<p>Creates a probability density given the values and optional weights provided, in &ldquo;value:weight value:weight &hellip;&rdquo; form.
The weight can be elided for any value to use the default weight of 1.0d.</p>

<p>@see <a href="http://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math4/distribution/EnumeratedRealDistribution.html">Commons JavaDoc: EnumeratedRealDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Enumerated(String: data, String[]&hellip;: mods) -&gt; double

<ul>
<li><em>ex:</em> <code>Enumerated('1 2 3 4 5 6')</code> - <em>a fair six-sided die roll</em></li>
<li><em>ex:</em> <code>Enumerated('1:2.0 2 3 4 5 6')</code> - <em>an unfair six-sided die roll, where 1 has probability mass 2.0, and everything else has only 1.0</em></li>
</ul></li>
<li>long -&gt; Enumerated(String: data, String[]&hellip;: mods) -&gt; double

<ul>
<li><em>ex:</em> <code>Enumerated('1 2 3 4 5 6')</code> - <em>a fair 6-sided die</em></li>
<li><em>ex:</em> <code>Enumerated('1:2.0 2 3 4 5:0.5 6:0.5')</code> - <em>an unfair fair 6-sided die, where ones are twice as likely, and fives and sixes are half as likely</em></li>
</ul></li>
</ul>

<h2 id="exponential">Exponential</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Exponential_distribution">Wikipedia: Exponential distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ExponentialDistribution.html">Commons JavaDoc: ExponentialDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Exponential(double: mean, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Exponential(double: mean, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="expr">Expr</h2>

<p>Allow for the use of arbitrary expressions according to the
<a href="http://mvel.documentnode.com/">MVEL</a> expression language.</p>

<p>Variables that have been set by a Save function are available
to be used in this function.</p>

<p>The variable name <strong>cycle</strong> is reserved, and is always equal to
the current input value.</p>

<ul>
<li>double -&gt; Expr(String: expr) -&gt; double</li>
<li>long -&gt; Expr(String: expr) -&gt; int</li>
<li>long -&gt; Expr(String: expr) -&gt; long</li>
<li>int -&gt; Expr(String: expr) -&gt; int</li>
</ul>

<h2 id="f">F</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/F-distribution">Wikipedia: F-distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/FDistribution.html">Commons JavaDoc: FDistribution</a>
@see <a href="http://mathworld.wolfram.com/F-Distribution.html">Mathworld: F-Distribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; F(double: numeratorDegreesOfFreedom, double: denominatorDegreesOfFreedom, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; F(double: numeratorDegreesOfFreedom, double: denominatorDegreesOfFreedom, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="fieldextractor">FieldExtractor</h2>

<p>Extracts out a set of fields from a delimited string, returning
a string with the same delimiter containing only the specified fields.
The</p>

<ul>
<li>String -&gt; FieldExtractor(String: fields) -&gt; String

<ul>
<li><em>ex:</em> <code>FieldExtractor('|,2,16')</code> - <em>extract fields 2 and 16 from the input data with &lsquo;|&rsquo; as the delimiter</em></li>
</ul></li>
</ul>

<h2 id="firstnames">FirstNames</h2>

<p>Return a pseudo-randomly sampled first name from the last US census data on first names
occurring more than 100 times. Both male and female names are combined in this function.</p>

<ul>
<li>long -&gt; FirstNames() -&gt; String

<ul>
<li><em>ex:</em> <code>FirstNames()</code> - <em>select a random first name based on the chance of seeing it in the census data</em></li>
</ul></li>
<li>long -&gt; FirstNames(String: modifier) -&gt; String

<ul>
<li><em>ex:</em> <code>FirstNames('map')</code> - <em>select over the first names by probability as input varies from 1L to Long.MAX_VALUE</em></li>
</ul></li>
</ul>

<h2 id="fixedvalue">FixedValue</h2>

<p>Yield a fixed value.</p>

<ul>
<li>long -&gt; FixedValue(int: value) -&gt; int

<ul>
<li><em>ex:</em> <code>FixedValue(42)</code> - <em>always return 42</em></li>
</ul></li>
<li>long -&gt; FixedValue(long: fixedValue) -&gt; long</li>
</ul>

<h2 id="fixedvalues">FixedValues</h2>

<p>Yield one of the specified values, rotating through them as the input value
increases.</p>

<ul>
<li>long -&gt; FixedValues(int[]&hellip;: values) -&gt; int</li>
<li>long -&gt; FixedValues(long[]&hellip;: values) -&gt; long

<ul>
<li><em>ex:</em> <code>FixedValues(3L,53L,73L)</code> - <em>Yield 3L, 53L, 73L, 3L, 53L, 73L, 3L, &hellip;</em></li>
</ul></li>
</ul>

<h2 id="format">Format</h2>

<p>Apply the Java String.format method to an incoming object.
@see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">Java 8 String.format(&hellip;) javadoc</a>
Note: This function can often be quite slow, so more direct methods are generally preferrable.</p>

<ul>
<li>Object -&gt; Format(String: format) -&gt; String

<ul>
<li><em>ex:</em> <code>Format('Y')</code> - <em>Yield the formatted year from a Java date object.</em></li>
</ul></li>
</ul>

<h2 id="fullhash">FullHash</h2>

<p>This uses the Murmur3F (64-bit optimized) version of Murmur3,
not as a checksum, but as a simple hash. It doesn&rsquo;t bother
pushing the high-64 bits of input, since it only uses the lower
64 bits of output.</p>

<p>This version returns the value regardless of this sign bit.
It does not return the absolute value, as Hash does.</p>

<ul>
<li>long -&gt; FullHash() -&gt; long</li>
</ul>

<h2 id="fullnames">FullNames</h2>

<p>Combines the FirstNames and LastNames functions into one that
simply concatenates them with a space between.
This function is a shorthand equivalent of {@code Template(&lsquo;{} {}&rsquo;, FirstNames(), LastNames())}</p>

<ul>
<li>long -&gt; FullNames() -&gt; String</li>
</ul>

<h2 id="gamma">Gamma</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Gamma_distribution">Wikipedia: Gamma distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/GammaDistribution.html">Commons JavaDoc: GammaDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Gamma(double: shape, double: scale, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Gamma(double: shape, double: scale, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="geometric">Geometric</h2>

<p>@see <a href="http://en.wikipedia.org/wiki/Geometric_distribution">Wikipedia: Geometric distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/GeometricDistribution.html">Commons JavaDoc: GeometricDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function based on inverse cumulative
 density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Geometric(double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Geometric(double: p, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Geometric(double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Geometric(double: p, String[]&hellip;: modslist) -&gt; long</li>
</ul>

<h2 id="gumbel">Gumbel</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Gumbel_distribution">Wikipedia: Gumbel distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/GumbelDistribution.html">Commons JavaDoc: GumbelDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Gumbel(double: mu, double: beta, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Gumbel(double: mu, double: beta, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="hash">Hash</h2>

<p>This uses the Murmur3F (64-bit optimized) version of Murmur3,
not as a checksum, but as a simple hash. It doesn&rsquo;t bother
pushing the high-64 bits of input, since it only uses the lower
64 bits of output. It does, however, return the absolute value.
This is to make it play nice with users and other libraries.</p>

<ul>
<li>long -&gt; Hash() -&gt; int</li>
<li>long -&gt; Hash() -&gt; long</li>
<li>int -&gt; Hash() -&gt; int</li>
</ul>

<h2 id="hashrange">HashRange</h2>

<p>Return a value within a range, pseudo-randomly. This is equivalent to
returning a value with in range between 0 and some maximum value, but
with a minimum value added.</p>

<ul>
<li>long -&gt; HashRange(long: width) -&gt; int</li>
<li>long -&gt; HashRange(long: minValue, long: maxValue) -&gt; int</li>
<li>long -&gt; HashRange(long: width) -&gt; long</li>
<li>long -&gt; HashRange(long: minValue, long: maxValue) -&gt; long</li>
<li>int -&gt; HashRange(int: width) -&gt; int</li>
<li>int -&gt; HashRange(int: minValue, int: maxValue) -&gt; int</li>
</ul>

<h2 id="hashrangescaled">HashRangeScaled</h2>

<p>Return a pseudo-random value which can only be as large as the input.</p>

<ul>
<li>long -&gt; HashRangeScaled() -&gt; int</li>
<li>long -&gt; HashRangeScaled() -&gt; long</li>
<li>int -&gt; HashRangeScaled() -&gt; int</li>
</ul>

<h2 id="hasheddoublerange">HashedDoubleRange</h2>

<p>Return a double value within the specified range. This function
uses an intermediate long to arrive at the sampled value before
conversion to double, thus providing a more linear sample at the
expense of some precision at extremely large values.</p>

<ul>
<li>long -&gt; HashedDoubleRange(double: min, double: max) -&gt; double</li>
</ul>

<h2 id="hashedfileextracttostring">HashedFileExtractToString</h2>

<p>Pseudo-randomly extract a section of a text file and return it according to some
minimum and maximum extract size. The file is loaded into memory as a shared
text image. It is then indexed into as a character buffer to find a pseudo-randomly
sized fragment.</p>

<ul>
<li>long -&gt; HashedFileExtractToString(String: fileName, int: minsize, int: maxsize) -&gt; String

<ul>
<li><em>ex:</em> <code>HashedFileExtractToString('data/adventures.txt',100,200)</code> - <em>return a fragment from adventures.txt between 100 and 200 characters long</em></li>
</ul></li>
</ul>

<h2 id="hashedlinetoint">HashedLineToInt</h2>

<p>Return a pseudo-randomly selected integer value from a file of numeric values.
Each line in the file must contain one parsable integer value.</p>

<ul>
<li>long -&gt; HashedLineToInt(String: filename) -&gt; int</li>
</ul>

<h2 id="hashedlinetostring">HashedLineToString</h2>

<p>Return a pseudo-randomly selected String value from a single line of
the specified file.</p>

<ul>
<li>long -&gt; HashedLineToString(String: filename) -&gt; String</li>
</ul>

<h2 id="hashedlinetostringlist">HashedLineToStringList</h2>

<ul>
<li>long -&gt; HashedLineToStringList(String: filename, int: minSize, int: maxSize) -&gt; java.util.List</li>
</ul>

<h2 id="hashedlinetostringset">HashedLineToStringSet</h2>

<p>Return a pseudo-randomly created Set from the values in
the specified file.</p>

<ul>
<li>long -&gt; HashedLineToStringSet(String: filename, int: minSize, int: maxSize) -&gt; java.util.Set<String>

<ul>
<li><em>ex:</em> <code>HashedLineToStringSet('data/variable_words.txt',2,10)</code> - <em>Create a set of words sized between 2 and 10 elements</em></li>
</ul></li>
</ul>

<h2 id="hashedlinetostringstringmap">HashedLineToStringStringMap</h2>

<p>Create a String-String map from the specified file, ranging in size
from 0 to the specified maximum.</p>

<ul>
<li>long -&gt; HashedLineToStringStringMap(String: paramFile, int: maxSize) -&gt; java.util.Map<String,String></li>
</ul>

<h2 id="hashedlinestokeyvaluestring">HashedLinesToKeyValueString</h2>

<p>Generate a string in the format key1:value1;key2:value2;&hellip; from the words
in the specified file, ranging in size between zero and the specified maximum.</p>

<ul>
<li>long -&gt; HashedLinesToKeyValueString(String: paramFile, int: maxsize) -&gt; String</li>
</ul>

<h2 id="hashedloremextracttostring">HashedLoremExtractToString</h2>

<p>Provide a text extract from the full lorem ipsum text, between the specified
minimum and maximum size.</p>

<ul>
<li>long -&gt; HashedLoremExtractToString(int: minsize, int: maxsize) -&gt; String</li>
</ul>

<h2 id="hashedrangetolonglist">HashedRangeToLongList</h2>

<p>Create a list of longs.</p>

<ul>
<li>long -&gt; HashedRangeToLongList(int: minVal, int: maxVal, int: minSize, int: maxSize) -&gt; java.util.List<Long></li>
</ul>

<h2 id="hashedrangedtononuniformdouble">HashedRangedToNonuniformDouble</h2>

<p>This provides a random sample of a double in a range, without
accounting for the non-uniform distribution of IEEE double representation.
This means that values closer to high-precision areas of the IEEE spec
will be weighted higher in the output. However, NaN and positive and
negative infinity are filtered out via oversampling. Results are still
stable for a given input value.</p>

<ul>
<li>long -&gt; HashedRangedToNonuniformDouble(long: min, long: max) -&gt; double</li>
</ul>

<h2 id="hashedtobytebuffer">HashedToByteBuffer</h2>

<p>Hash a long input value into a byte buffer, at least length bytes long, but aligned on 8-byte
boundary;</p>

<ul>
<li>long -&gt; HashedToByteBuffer(int: lengthInBytes) -&gt; java.nio.ByteBuffer</li>
</ul>

<h2 id="hypergeometric">Hypergeometric</h2>

<p>@see <a href="http://en.wikipedia.org/wiki/Hypergeometric_distribution">Wikipedia: Hypergeometric distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/HypergeometricDistribution.html">Commons JavaDoc: HypergeometricDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function based on inverse cumulative
 density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Hypergeometric(int: populationSize, int: numberOfSuccesses, int: sampleSize, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Hypergeometric(int: populationSize, int: numberOfSuccesses, int: sampleSize, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Hypergeometric(int: populationSize, int: numberOfSuccesses, int: sampleSize, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Hypergeometric(int: populationSize, int: numberOfSuccesses, int: sampleSize, String[]&hellip;: modslist) -&gt; long</li>
</ul>

<h2 id="identity">Identity</h2>

<p>Simply returns the input value. This function intentionally does nothing.</p>

<ul>
<li>long -&gt; Identity() -&gt; long</li>
</ul>

<h2 id="interpolate">Interpolate</h2>

<p>Return a value along an interpolation curve. This allows you to sketch a basic
density curve and describe it simply with just a few values. The number of values
provided determines the resolution of the internal lookup table that is used for
interpolation. The first value is always the 0.0 anchoring point on the unit interval.
The last value is always the 1.0 anchoring point on the unit interval. This means
that in order to subdivide the density curve in an interesting way, you need to provide
a few more values in between them. Providing two values simply provides a uniform
sample between a minimum and maximum value.</p>

<p>The input range of this function is, as many of the other functions in this library,
based on the valid range of positive long values, between 0L and Long.MAX_VALUE inclusive.
This means that if you want to combine interpolation on this curve with the effect of
pseudo-random sampling, you need to put a hash function ahead of it in the flow.</p>

<ul>
<li>long -&gt; Interpolate(double[]&hellip;: value) -&gt; double

<ul>
<li><em>ex:</em> <code>Interpolate(0.0d,100.0d)</code> - <em>return a uniform double value between 0.0d and 100.0d</em></li>
<li><em>ex:</em> <code>Interpolate(0.0d,90.0d,95.0d,98.0d,100.0d)</code> - <em>return a weighted double value where the first second and third quartiles are 90.0D, 95.0D, and 98.0D</em></li>
</ul></li>
<li>long -&gt; Interpolate(int: resolution, double[]: lut) -&gt; double</li>
<li>long -&gt; Interpolate(double[]&hellip;: value) -&gt; long

<ul>
<li><em>ex:</em> <code>Interpolate(0.0d,100.0d)</code> - <em>return a uniform long value between 0L and 100L</em></li>
<li><em>ex:</em> <code>Interpolate(0.0d,90.0d,95.0d,98.0d,100.0d)</code> - <em>return a weighted long value where the first second and third quartiles are 90.0D, 95.0D, and 98.0D</em></li>
</ul></li>
<li>long -&gt; Interpolate(long[]&hellip;: value) -&gt; long</li>
<li>long -&gt; Interpolate(int: resolution, double[]: lut) -&gt; long</li>
</ul>

<h2 id="jointemplate">JoinTemplate</h2>

<p>Combine the result of the specified functions together with the
specified delimiter and optional prefix and suffix.</p>

<ul>
<li>long -&gt; JoinTemplate(String: delimiter, java.util.function.LongFunction&lt;?&gt;[]&hellip;: funcs) -&gt; String

<ul>
<li><em>ex:</em> <code>JoinTemplate('--',NumberNameToString(),NumberNameToString())</code> - <em>create values like <code>one--one</code>, <code>two-two</code>, &hellip;</em></li>
</ul></li>
<li>long -&gt; JoinTemplate(String: prefix, String: delimiter, String: suffix, java.util.function.LongFunction&lt;?&gt;[]&hellip;: funcs) -&gt; String

<ul>
<li><em>ex:</em> <code>JoinTemplate('{',',','}',NumberNameToString(),LastNames())</code> - <em>create values like &lsquo;{one,Farrel}&rsquo;, &lsquo;{two,Haskell}&rsquo;, &hellip;</em></li>
</ul></li>
<li>long -&gt; JoinTemplate(java.util.function.LongUnaryOperator: iterop, String: prefix, String: delimiter, String: suffix, java.util.function.LongFunction&lt;?&gt;[]&hellip;: funcs) -&gt; String

<ul>
<li><em>ex:</em> <code>JoinTemplate(Add(3),'[',';',']',NumberNameToString(),NumberNameToString(),NumberNameToString())</code> - <em>create values like &lsquo;[zero;three,six]&lsquo;, &lsquo;[one;four,seven]&lsquo;, &hellip;</em></li>
</ul></li>
</ul>

<h2 id="laplace">Laplace</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Laplace_distribution">Wikipedia: Laplace distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/LaplaceDistribution.html">Commons JavaDoc: LaplaceDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Laplace(double: mu, double: beta, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Laplace(double: mu, double: beta, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="lastnames">LastNames</h2>

<p>Return a pseudo-randomly sampled last name from the last US census data on last names
occurring more than 100 times.</p>

<ul>
<li>long -&gt; LastNames() -&gt; String

<ul>
<li><em>ex:</em> <code>LastNames()</code> - <em>select a random last name based on the chance of seeing it in the census data</em></li>
</ul></li>
<li>long -&gt; LastNames(String: modifier) -&gt; String

<ul>
<li><em>ex:</em> <code>LastNames('map')</code> - <em>select over the last names by probability as input varies from 1L to Long.MAX_VALUE</em></li>
</ul></li>
</ul>

<h2 id="levy">Levy</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/L%C3%A9vy_distribution">Wikipedia: Lvy distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/LevyDistribution.html">Commons JavaDoc: LevyDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Levy(double: mu, double: c, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Levy(double: mu, double: c, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="listtemplate">ListTemplate</h2>

<p>Create a {@code List<String>} based on two functions, the first to
determine the list size, and the second to populate the list with
string values. The input fed to the second function is incremented
between elements.</p>

<ul>
<li>long -&gt; ListTemplate(java.util.function.LongToIntFunction: sizeFunc, java.util.function.LongFunction<String>: valueFunc) -&gt; java.util.List<String>

<ul>
<li><em>ex:</em> <code>ListTemplate(HashRange(3,7),NumberNameToString())</code> - <em>create a list between 3 and 7 elements, with number names as the values</em></li>
</ul></li>
</ul>

<h2 id="load">Load</h2>

<p>Load a named value from the per-thread state map.
The previous input value will be forgotten, and the named value will replace it
before the next function in the chain.</p>

<ul>
<li>double -&gt; Load(String: name) -&gt; double

<ul>
<li><em>ex:</em> <code>Load('foo')</code> - <em>load a double value from the named variable for this thread</em></li>
</ul></li>
<li>long -&gt; Load(String: name) -&gt; long

<ul>
<li><em>ex:</em> <code>Load('foo')</code> - <em>load a long value from the named variable for this thread</em></li>
</ul></li>
<li>Object -&gt; Load(String: name) -&gt; Object

<ul>
<li><em>ex:</em> <code>Load('foo')</code> - <em>load a Object value from the named variable for this thread</em></li>
</ul></li>
<li>int -&gt; Load(String: name) -&gt; int

<ul>
<li><em>ex:</em> <code>Load('foo')</code> - <em>load an int value from the named variable for this thread</em></li>
</ul></li>
<li>String -&gt; Load(String: name) -&gt; String

<ul>
<li><em>ex:</em> <code>Load('foo')</code> - <em>load a String value from the named variable for this thread</em></li>
</ul></li>
</ul>

<h2 id="lognormal">LogNormal</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Log-normal_distribution">Wikipedia: Log-normal distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/LogNormalDistribution.html">Commons JavaDoc: LogNormalDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; LogNormal(double: scale, double: shape, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; LogNormal(double: scale, double: shape, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="logistic">Logistic</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Logistic_distribution">Wikipedia: Logistic distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/LogisticDistribution.html">Commons JavaDoc: LogisticDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Logistic(double: mu, double: scale, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Logistic(double: mu, double: scale, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="longtobyte">LongToByte</h2>

<p>Convert the input long value to a byte, with negative values
masked away.</p>

<ul>
<li>long -&gt; LongToByte() -&gt; Byte</li>
</ul>

<h2 id="longtoshort">LongToShort</h2>

<p>Convert the input value from long to short.</p>

<ul>
<li>long -&gt; LongToShort() -&gt; Short</li>
</ul>

<h2 id="longtostring">LongToString</h2>

<p>Return the string representation of the provided long.</p>

<ul>
<li>long -&gt; LongToString() -&gt; String</li>
</ul>

<h2 id="maptemplate">MapTemplate</h2>

<p>Construct a {@code Map<String,String>} from a set of input functions
which determine the size of the map, the value of each key, and
the value for that key. In between calling the key and value functions,
the input value is incremented.</p>

<ul>
<li>long -&gt; MapTemplate(java.util.function.LongToIntFunction: sizeFunc, java.util.function.LongFunction<String>: keyFunc, java.util.function.LongFunction<String>: valueFunc) -&gt; java.util.Map<String,String>

<ul>
<li><em>ex:</em> <code>MapTemplate(HashRange(3-7),NumberNameToString(),LastNames())</code> - <em>create maps between 3 and 7 values big, with number names as the keys, and last names as the values</em></li>
</ul></li>
</ul>

<h2 id="max">Max</h2>

<p>Return the maximum of either the input value or the specified max.</p>

<ul>
<li>double -&gt; Max(double: max) -&gt; double</li>
<li>long -&gt; Max(long: max) -&gt; long

<ul>
<li><em>ex:</em> <code>Max(42L)</code> - <em>take the value of 42L or the input, which ever is greater</em></li>
<li><em>ex:</em> <code>Max(-42L)</code> - <em>take the value of -42L or the input, which ever is greater</em></li>
</ul></li>
<li>int -&gt; Max(int: max) -&gt; int</li>
</ul>

<h2 id="min">Min</h2>

<p>Return the minimum of either the input value or the specified minimum.</p>

<ul>
<li>double -&gt; Min(double: min) -&gt; double</li>
<li>long -&gt; Min(long: min) -&gt; long</li>
<li>int -&gt; Min(int: min) -&gt; int</li>
</ul>

<h2 id="mod">Mod</h2>

<p>Return the result of modulo division by the specified divisor.</p>

<ul>
<li>long -&gt; Mod(long: modulo) -&gt; int</li>
<li>long -&gt; Mod(long: modulo) -&gt; long</li>
<li>int -&gt; Mod(int: modulo) -&gt; int</li>
</ul>

<h2 id="modulolinetostring">ModuloLineToString</h2>

<p>Select a value from a text file line by modulo division against the number
of lines in the file.</p>

<ul>
<li>long -&gt; ModuloLineToString(String: filename) -&gt; String</li>
</ul>

<h2 id="modulotobigdecimal">ModuloToBigDecimal</h2>

<p>Return a {@code BigDecimal} value as the result of modulo division with the specified divisor.</p>

<ul>
<li>long -&gt; ModuloToBigDecimal() -&gt; java.math.BigDecimal</li>
<li>long -&gt; ModuloToBigDecimal(long: modulo) -&gt; java.math.BigDecimal</li>
</ul>

<h2 id="modulotobigint">ModuloToBigInt</h2>

<p>Return a {@code BigInteger} value as the result of modulo division with the specified divisor.</p>

<ul>
<li>long -&gt; ModuloToBigInt() -&gt; java.math.BigInteger</li>
<li>long -&gt; ModuloToBigInt(long: modulo) -&gt; java.math.BigInteger</li>
</ul>

<h2 id="modulotoboolean">ModuloToBoolean</h2>

<p>Return a boolean value as the result of modulo division with the specified divisor.</p>

<ul>
<li>long -&gt; ModuloToBoolean() -&gt; Boolean</li>
</ul>

<h2 id="modulotobyte">ModuloToByte</h2>

<p>Return a byte value as the result of modulo division with the specified divisor.</p>

<ul>
<li>long -&gt; ModuloToByte(long: modulo) -&gt; Byte</li>
</ul>

<h2 id="modulotointeger">ModuloToInteger</h2>

<p>Return an integer value as the result of modulo division with the specified divisor.</p>

<ul>
<li>long -&gt; ModuloToInteger(int: modulo) -&gt; Integer</li>
</ul>

<h2 id="modulotolong">ModuloToLong</h2>

<p>Return a long value as the result of modulo division with the specified divisor.</p>

<ul>
<li>long -&gt; ModuloToLong(long: modulo) -&gt; long</li>
</ul>

<h2 id="modulotoshort">ModuloToShort</h2>

<p>Return a boolean value as the result of modulo division with the specified divisor.</p>

<ul>
<li>long -&gt; ModuloToShort(long: modulo) -&gt; Short</li>
</ul>

<h2 id="mul">Mul</h2>

<p>Return the result of multiplying the specified value with the input.</p>

<ul>
<li>double -&gt; Mul(double: factor) -&gt; double</li>
<li>long -&gt; Mul(long: multiplicand) -&gt; int</li>
<li>long -&gt; Mul(long: multiplicand) -&gt; long</li>
<li>int -&gt; Mul(int: addend) -&gt; int</li>
</ul>

<h2 id="murmur3divtolong">Murmur3DivToLong</h2>

<p>Yield a long value which is the result of hashing and modulo division
with the specified divisor.</p>

<ul>
<li>long -&gt; Murmur3DivToLong(long: divisor) -&gt; long</li>
</ul>

<h2 id="murmur3divtostring">Murmur3DivToString</h2>

<p>Yield a String value which is the result of hashing and modulo division
with the specified divisor to long and then converting the value to String.</p>

<ul>
<li>long -&gt; Murmur3DivToString(long: divisor) -&gt; String</li>
</ul>

<h2 id="nakagami">Nakagami</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Nakagami_distribution">Wikipedia: Nakagami distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/NakagamiDistribution.html">Commons JavaDoc: NakagamiDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Nakagami(double: mu, double: omega, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Nakagami(double: mu, double: omega, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="normal">Normal</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Normal_distribution">Wikipedia: Normal distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/NormalDistribution.html">Commons JavaDoc: NormalDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Normal(double: mean, double: sd, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Normal(double: mean, double: sd, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="numbernametostring">NumberNameToString</h2>

<ul>
<li>long -&gt; NumberNameToString() -&gt; String</li>
</ul>

<h2 id="pareto">Pareto</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Pareto_distribution">Wikipedia: Pareto distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ParetoDistribution.html">Commons JavaDoc: ParetoDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Pareto(double: scale, double: shape, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Pareto(double: scale, double: shape, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="pascal">Pascal</h2>

<p>@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/PascalDistribution.html">Commons JavaDoc: PascalDistribution</a>
@see <a href="https://en.wikipedia.org/wiki/Negative_binomial_distribution">Wikipedia: Negative binomial distribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function based on inverse cumulative
 density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Pascal(int: r, double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Pascal(int: r, double: p, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Pascal(int: r, double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Pascal(int: r, double: p, String[]&hellip;: modslist) -&gt; long</li>
</ul>

<h2 id="poisson">Poisson</h2>

<p>@see <a href="http://en.wikipedia.org/wiki/Poisson_distribution">Wikipedia: Poisson distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/PoissonDistribution.html">Commons JavaDoc: PoissonDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function based on inverse cumulative
 density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Poisson(double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Poisson(double: p, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Poisson(double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Poisson(double: p, String[]&hellip;: modslist) -&gt; long</li>
</ul>

<h2 id="prefix">Prefix</h2>

<p>Add the specified prefix String to the input value and return the result.</p>

<ul>
<li>String -&gt; Prefix(String: prefix) -&gt; String

<ul>
<li><em>ex:</em> <code>Prefix('PREFIX:')</code> - <em>Prepend &lsquo;PREFIX:&rsquo; to every input value</em></li>
</ul></li>
</ul>

<h2 id="save">Save</h2>

<p>Save the current input value at this point in the function chain to a thread-local variable name.
The input value is unchanged, and available for the next function in the chain to use as-is.</p>

<ul>
<li>double -&gt; Save(String: name) -&gt; double

<ul>
<li><em>ex:</em> <code>Save('foo')</code> - <em>save the current double value to the name &lsquo;foo&rsquo; in this thread</em></li>
</ul></li>
<li>long -&gt; Save(String: name) -&gt; long

<ul>
<li><em>ex:</em> <code>Save('foo')</code> - <em>save the current long value to the name &lsquo;foo&rsquo; in this thread</em></li>
</ul></li>
<li>Object -&gt; Save(String: name) -&gt; Object

<ul>
<li><em>ex:</em> <code>Save('foo')</code> - <em>save the current input object value to the name &lsquo;foo&rsquo; in this thread</em></li>
</ul></li>
<li>int -&gt; Save(String: name) -&gt; int

<ul>
<li><em>ex:</em> <code>Save('foo')</code> - <em>save the current int value to the name &lsquo;foo&rsquo; in this thread</em></li>
</ul></li>
<li>String -&gt; Save(String: name) -&gt; String

<ul>
<li><em>ex:</em> <code>Save('foo')</code> - <em>save the current String value to the name &lsquo;foo&rsquo; in this thread</em></li>
</ul></li>
</ul>

<h2 id="scale">Scale</h2>

<p>Scale the input to the</p>

<ul>
<li>long -&gt; Scale(double: scaleFactor) -&gt; int</li>
<li>int -&gt; Scale(double: scaleFactor) -&gt; int</li>
</ul>

<h2 id="show">Show</h2>

<p>Show diagnostic values for the thread-local variable map.</p>

<ul>
<li>Object -&gt; Show() -&gt; String

<ul>
<li><em>ex:</em> <code>Show()</code> - <em>Show all values in a json-like format</em></li>
</ul></li>
<li>Object -&gt; Show(String[]&hellip;: names) -&gt; String

<ul>
<li><em>ex:</em> <code>Show('foo')</code> - <em>Show only the &lsquo;foo&rsquo; value in a json-like format</em></li>
<li><em>ex:</em> <code>Show('foo','bar')</code> - <em>Show the &lsquo;foo&rsquo; and &lsquo;bar&rsquo; values in a json-like format</em></li>
</ul></li>
</ul>

<h2 id="shuffle">Shuffle</h2>

<p>This function provides a low-overhead shuffling effect without loading
elements into memory. It uses a bundled dataset of pre-computed
Galois LFSR shift register configurations, along with a down-sampling
method to provide amortized virtual shuffling with minimal memory usage.</p>

<p>Essentially, this guarantees that every value in the specified range will
be seen at least once before the cycle repeats. However, since the order
of traversal of these values is dependent on the LFSR configuration, some
orders will appear much more random than others depending on where you
are in the traversal cycle.</p>

<p>This function <em>does</em> yield values that are deterministic.</p>

<ul>
<li>long -&gt; Shuffle(long: min, long: maxPlusOne) -&gt; long

<ul>
<li><em>ex:</em> <code>Shuffle(11,99)</code> - <em>Provide all values between 11 and 98 inclusive, in some order, then repeat</em></li>
</ul></li>
<li>long -&gt; Shuffle(long: min, long: maxPlusOne, int: bankSelector) -&gt; long

<ul>
<li><em>ex:</em> <code>Shuffle(11,99,3)</code> - <em>Provide all values between 11 and 98 inclusive, in some different (and repeatable) order, then repeat</em></li>
</ul></li>
</ul>

<h2 id="signedhash">SignedHash</h2>

<p>This uses the Murmur3F (64-bit optimized) version of Murmur3,
not as a checksum, but as a simple hash. It doesn&rsquo;t bother
pushing the high-64 bits of input, since it only uses the lower
64 bits of output.</p>

<p>Unlike the other hash functions, this one may return positive
as well as negative values.</p>

<ul>
<li>long -&gt; SignedHash() -&gt; int</li>
<li>long -&gt; SignedHash() -&gt; long</li>
<li>int -&gt; SignedHash() -&gt; int</li>
</ul>

<h2 id="startingepochmillis">StartingEpochMillis</h2>

<p>This function sets the minimum long value to the equivalent
unix epoch time in milliseconds. It simply adds the input
value to this base value as determined by the provided
time specifier. It wraps any overflow within this range as well.</p>

<ul>
<li>long -&gt; StartingEpochMillis(String: baseTimeSpec) -&gt; long

<ul>
<li><em>ex:</em> <code>StartingEpochMillis('2017-01-01 23:59:59')</code> - <em>add the millisecond epoch time of 2017-01-01 23:59:59 to all input values</em></li>
</ul></li>
</ul>

<h2 id="staticstringmapper">StaticStringMapper</h2>

<p>Return a static String value.</p>

<ul>
<li>long -&gt; StaticStringMapper(String: string) -&gt; String</li>
</ul>

<h2 id="stringdatewrapper">StringDateWrapper</h2>

<ul>
<li>long -&gt; StringDateWrapper(String: format) -&gt; String</li>
</ul>

<h2 id="suffix">Suffix</h2>

<p>Add the specified prefix String to the input value and return the result.</p>

<ul>
<li>String -&gt; Suffix(String: suffix) -&gt; String

<ul>
<li><em>ex:</em> <code>Suffix('--Fin')</code> - <em>Append &lsquo;&ndash;Fin&rsquo; to every input value</em></li>
</ul></li>
</ul>

<h2 id="t">T</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Student's_t-distribution">Wikipedia: Student&rsquo;s t-distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/TDistribution.html">Commons JavaDoc: TDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; T(double: degreesOfFreedom, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; T(double: degreesOfFreedom, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="template">Template</h2>

<p>Creates a template function which will yield a string which fits the template
provided, with all occurrences of <code>{}</code> substituted pair-wise with the
result of the provided functions. The number of <code>{}</code> entries in the template
must strictly match the number of functions or an error will be thrown.</p>

<p>To provide differing values for similarly defined functions in the list, the input
value used is automatically incremented by one for each function, starting with
the initial input value.</p>

<ul>
<li>long -&gt; Template(String: template, java.util.function.LongFunction&lt;?&gt;[]&hellip;: funcs) -&gt; String

<ul>
<li><em>ex:</em> <code>Template('{}-{}',Add(10),Hash())</code> - <em>concatenate input+10, &lsquo;-&rsquo;, and a pseudo-random long</em></li>
</ul></li>
<li>long -&gt; Template(java.util.function.LongUnaryOperator: iterOp, String: template, java.util.function.LongFunction&lt;?&gt;[]&hellip;: funcs) -&gt; String

<ul>
<li><em>notes:</em> If an operator is provided, it is used to change the function input value in an additional way before each function.</li>
</ul></li>
</ul>

<h2 id="threadnum">ThreadNum</h2>

<p>Matches a digit sequence in the current thread name and caches it in a thread local.
This allows you to use any intentionally indexed thread factories to provide an analogue for
concurrency. Note that once the thread number is cached, it will not be refreshed. This means
you can&rsquo;t change the thread name and get an updated value.</p>

<ul>
<li>long -&gt; ThreadNum() -&gt; int</li>
<li>long -&gt; ThreadNum() -&gt; long</li>
</ul>

<h2 id="threadnumtointeger">ThreadNumToInteger</h2>

<p>Matches a digit sequence in the current thread name and caches it in a thread local.
This allows you to use any intentionally indexed thread factories to provide an analogue for
concurrency. Note that once the thread number is cached, it will not be refreshed. This means
you can&rsquo;t change the thread name and get an updated value.</p>

<ul>
<li>long -&gt; ThreadNumToInteger() -&gt; Integer</li>
</ul>

<h2 id="threadnumtolong">ThreadNumToLong</h2>

<p>Matches a digit sequence in the current thread name and caches it in a thread local.
This allows you to use any intentionally indexed thread factories to provide an analogue for
concurrency. Note that once the thread number is cached, it will not be refreshed. This means
you can&rsquo;t change the thread name and get an updated value.</p>

<ul>
<li>long -&gt; ThreadNumToLong() -&gt; long</li>
</ul>

<h2 id="tobigint">ToBigInt</h2>

<p>Convert the input value to a {@code BigInteger}</p>

<ul>
<li>long -&gt; ToBigInt() -&gt; java.math.BigInteger</li>
</ul>

<h2 id="toboolean">ToBoolean</h2>

<p>Convert the input value to a {@code boolean}</p>

<ul>
<li>long -&gt; ToBoolean() -&gt; Boolean</li>
<li>Double -&gt; ToBoolean() -&gt; Boolean</li>
<li>Float -&gt; ToBoolean() -&gt; Boolean</li>
<li>Integer -&gt; ToBoolean() -&gt; Boolean</li>
</ul>

<h2 id="tobyte">ToByte</h2>

<p>Convert the input value to a {@code Byte}.</p>

<ul>
<li>double -&gt; ToByte() -&gt; Byte</li>
<li>double -&gt; ToByte(int: modulo) -&gt; Byte</li>
<li>Float -&gt; ToByte() -&gt; Byte</li>
<li>Float -&gt; ToByte(int: modulo) -&gt; Byte</li>
<li>int -&gt; ToByte() -&gt; Byte</li>
<li>int -&gt; ToByte(int: modulo) -&gt; Byte</li>
<li>long -&gt; ToByte() -&gt; Byte</li>
<li>long -&gt; ToByte(int: modulo) -&gt; Byte</li>
<li>Short -&gt; ToByte(int: scale) -&gt; Byte</li>
<li>Short -&gt; ToByte() -&gt; Byte</li>
<li>String -&gt; ToByte() -&gt; Byte</li>
</ul>

<h2 id="tobytebuffer">ToByteBuffer</h2>

<p>Convert the input value to a {@code ByteBuffer}</p>

<ul>
<li>double -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>Float -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>int -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>long -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>Short -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>String -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
</ul>

<h2 id="todate">ToDate</h2>

<p>Convert the input value to a {@code Date}</p>

<ul>
<li>long -&gt; ToDate(int: spacing, int: repeat_count) -&gt; java.util.Date</li>
<li>long -&gt; ToDate(int: spacing) -&gt; java.util.Date</li>
<li>long -&gt; ToDate() -&gt; java.util.Date</li>
</ul>

<h2 id="todatetime">ToDateTime</h2>

<p>Convert the input value to a {@code org.joda.time.DateTime}</p>

<ul>
<li>long -&gt; ToDateTime(int: spacing, int: repeat_count) -&gt; org.joda.time.DateTime</li>
<li>long -&gt; ToDateTime(String: spacing) -&gt; org.joda.time.DateTime</li>
<li>long -&gt; ToDateTime() -&gt; org.joda.time.DateTime</li>
</ul>

<h2 id="todouble">ToDouble</h2>

<p>Convert the input value to a double.</p>

<ul>
<li>long -&gt; ToDouble() -&gt; double</li>
</ul>

<h2 id="toepochtimeuuid">ToEpochTimeUUID</h2>

<p>Converts a long UTC timestamp in epoch millis form into a Version 1 TimeUUID
according to <a href="https://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a>.
This means that only one unique value for a timeuuid can be generated for
each epoch milli value, even though version 1 TimeUUIDs can normally represent
up to 10000 distinct values per millisecond. If you need to access this
level of resolution for testing purposes, use ToFinestTimeUUID
instead. This method is to support simple mapping to natural timestamps
as we often find in the real world.</p>

<p>For the variants that have a String argument in the constructor, this is
a parsable datetime that is used as the base time for all produced values.
Setting this allows you to set the start of the time range for all timeuuid
values produced. All times are parsed for UTC. All time use ISO date ordering,
meaning that the most significant fields always go before the others.</p>

<p>The valid formats, in joda specifier form are:
<ol>
<li>yyyy-MM-dd HH:mm:ss.SSSZ, for example: 2015-02-28 23:30:15.223</li>
<li>yyyy-MM-dd HH:mm:ss, for example 2015-02-28 23:30:15</li>
<li>yyyyMMdd&rsquo;T&rsquo;HHmmss.SSSZ, for example: 20150228T233015.223</li>
<li>yyyyMMdd&rsquo;T&rsquo;HHmmssZ, for example: 20150228T233015</li>
<li>yyyy-MM-dd, for example: 2015-02-28</li>
<li>yyyyMMdd, for example: 20150228</li>
<li>yyyyMM, for example: 201502</li>
<li>yyyy, for example: 2015</li>
</ol></p>

<ul>
<li>long -&gt; ToEpochTimeUUID() -&gt; java.util.UUID

<ul>
<li><em>notes:</em> Create version 1 timeuuids with a per-host node and empty clock data.
The node and clock components are seeded from network interface data. In this case,
the clock data is not seeded uniquely.</li>
<li><em>ex:</em> <code>ToEpochTimeUUID()</code> - <em>basetime 0, computed node data, empty clock data</em></li>
</ul></li>

<li><p>long -&gt; ToEpochTimeUUID(long: node) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and empty clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToEpochTimeUUID(5234)</code> - <em>basetime 0, specified node data (5234), empty clock data</em></p></li>
</ul></li>

<li><p>long -&gt; ToEpochTimeUUID(long: node, long: clock) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and specific clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToEpochTimeUUID(31,337)</code> - <em>basetime 0, specified node data (31) and clock data (337)</em></p></li>
</ul></li>

<li><p>long -&gt; ToEpochTimeUUID(String: baseSpec) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a per-host node and empty clock data.
The node and clock components are seeded from network interface data. In this case,
the clock data is not seeded uniquely.</p></li>

<li><p><em>ex:</em> <code>ToEpochTimeUUID('2017-01-01T23:59:59')</code> - <em>specified basetime, computed node data, empty clock data</em></p></li>
</ul></li>

<li><p>long -&gt; ToEpochTimeUUID(String: baseSpec, long: node) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and empty clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToEpochTimeUUID('2012',12345)</code> - <em>basetime at start if 2012, with node data 12345, empty clock data</em></p></li>
</ul></li>

<li><p>long -&gt; ToEpochTimeUUID(String: baseSpec, long: node, long: clock) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and specific clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToEpochTimeUUID('20171231T1015.243',123,456)</code> - <em>ms basetime, specified node and clock data</em></p></li>
</ul></li>
</ul>

<h2 id="tofinesttimeuuid">ToFinestTimeUUID</h2>

<p>Converts a count of 100ns intervals from 1582 Julian to a Type1 TimeUUID
according to <a href="https://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a>.
This allows you to access the finest unit of resolution for the
purposes of simulating a large set of unique timeuuid values. This offers
10000 times more unique values per ms than ToEpochTimeUUID.</p>

<p>For the variants that have a String argument in the constructor, this is
a parsable datetime that is used as the base time for all produced values.
Setting this allows you to set the start of the time range for all timeuuid
values produced. All times are parsed for UTC. All time use ISO date ordering,
meaning that the most significant fields always go before the others.</p>

<p>The valid formats, in joda specifier form are:</p>

<ol>
<li>yyyy-MM-dd HH:mm:ss.SSSZ, for example: 2015-02-28 23:30:15.223</li>
<li>yyyy-MM-dd HH:mm:ss, for example 2015-02-28 23:30:15</li>
<li>yyyyMMdd'T'HHmmss.SSSZ, for example: 20150228T233015.223</li>
<li>yyyyMMdd'T'HHmmssZ, for example: 20150228T233015</li>
<li>yyyy-MM-dd, for example: 2015-02-28</li>
<li>yyyyMMdd, for example: 20150228</li>
<li>yyyyMM, for example: 201502</li>
<li>yyyy, for example: 2015</li>
</ol>

<ul>
<li>long -&gt; ToFinestTimeUUID() -&gt; java.util.UUID

<ul>
<li><em>notes:</em> Create version 1 timeuuids with a per-host node and empty clock data.
The node and clock components are seeded from network interface data. In this case,
the clock data is not seeded uniquely.</li>
<li><em>ex:</em> <code>ToFinestTimeUUID()</code> - <em>basetime 0, computed node data, empty clock data</em></li>
</ul></li>

<li><p>long -&gt; ToFinestTimeUUID(long: node) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and empty clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToFinestTimeUUID(5234)</code> - <em>basetime 0, specified node data (5234), empty clock data</em></p></li>
</ul></li>

<li><p>long -&gt; ToFinestTimeUUID(long: node, long: clock) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and specific clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToFinestTimeUUID(31,337)</code> - <em>basetime 0, specified node data (31) and clock data (337)</em></p></li>
</ul></li>

<li><p>long -&gt; ToFinestTimeUUID(String: baseTimeSpec) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a per-host node and empty clock data.
The node and clock components are seeded from network interface data. In this case,
the clock data is not seeded uniquely.</p></li>

<li><p><em>ex:</em> <code>ToFinestTimeUUID('2017-01-01T23:59:59')</code> - <em>specified basetime, computed node data, empty clock data</em></p></li>
</ul></li>

<li><p>long -&gt; ToFinestTimeUUID(String: baseTimeSpec, long: node) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and empty clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToFinestTimeUUID('2012',12345)</code> - <em>basetime at start if 2012, with node data 12345, empty clock data</em></p></li>
</ul></li>

<li><p>long -&gt; ToFinestTimeUUID(String: baseTimeSpec, long: node, long: clock) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and specific clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToFinestTimeUUID('20171231T1015.243',123,456)</code> - <em>ms basetime, specified node and clock data</em></p></li>
</ul></li>
</ul>

<h2 id="tofloat">ToFloat</h2>

<p>Convert the input value into a float.</p>

<ul>
<li>double -&gt; ToFloat(double: scale) -&gt; Float</li>
<li>double -&gt; ToFloat() -&gt; Float</li>
<li>int -&gt; ToFloat(int: scale) -&gt; Float</li>
<li>int -&gt; ToFloat() -&gt; Float</li>
<li>long -&gt; ToFloat(long: scale) -&gt; Float</li>
<li>long -&gt; ToFloat() -&gt; Float</li>
<li>Short -&gt; ToFloat() -&gt; Float</li>
<li>String -&gt; ToFloat() -&gt; Float</li>
</ul>

<h2 id="tohasheduuid">ToHashedUUID</h2>

<p>This function provides a stable hashing of the input value to
a version 4 (Random) UUID.</p>

<ul>
<li>long -&gt; ToHashedUUID() -&gt; java.util.UUID</li>
</ul>

<h2 id="toinetaddress">ToInetAddress</h2>

<p>Convert the input value to a {@code java.net.InetAddress}</p>

<ul>
<li>long -&gt; ToInetAddress() -&gt; java.net.InetAddress</li>
</ul>

<h2 id="toint">ToInt</h2>

<p>Convert the input value to a long.</p>

<ul>
<li>long -&gt; ToInt() -&gt; int</li>
<li>Object -&gt; ToInt() -&gt; Integer</li>
<li>double -&gt; ToInt(int: scale) -&gt; int</li>
<li>double -&gt; ToInt() -&gt; int</li>
<li>Double -&gt; ToInt(int: scale) -&gt; Integer</li>
<li>Double -&gt; ToInt() -&gt; Integer</li>
<li>long -&gt; ToInt(int: scale) -&gt; int</li>
<li>long -&gt; ToInt() -&gt; int</li>
<li>String -&gt; ToInt() -&gt; Integer</li>
</ul>

<h2 id="tojodadatetime">ToJodaDateTime</h2>

<p>Convert the input value to a {@code org.joda.time.DateTime}</p>

<ul>
<li>long -&gt; ToJodaDateTime(int: spacing, int: repeat_count) -&gt; org.joda.time.DateTime</li>
<li>long -&gt; ToJodaDateTime(String: spacing) -&gt; org.joda.time.DateTime</li>
<li>long -&gt; ToJodaDateTime() -&gt; org.joda.time.DateTime</li>
</ul>

<h2 id="tolong">ToLong</h2>

<p>Convert the input value to a long.</p>

<ul>
<li>double -&gt; ToLong(long: scale) -&gt; long</li>
<li>double -&gt; ToLong() -&gt; long</li>
<li>Float -&gt; ToLong(long: scale) -&gt; Long</li>
<li>Float -&gt; ToLong() -&gt; Long</li>
</ul>

<h2 id="tolongfunction">ToLongFunction</h2>

<p>Adapts any compatible FunctionalInterface type to a LongFunction,
for use with higher-order functions, when they require a
LongFunction as an argument. Some of the higher-order functions within
this library specifically require a LongFunction as an argument, while
some of the other functions are provided in semantically equivalent
forms with compatible types which can&rsquo;t be converted directly or
automatically by Java.</p>

<p>In such cases, those types of functions can be wrapped with the forms
described here in order to allow the inner and outer functions to work together.</p>

<ul>
<li>long -&gt; ToLongFunction(java.util.function.LongUnaryOperator: op) -&gt; Object</li>
<li>long -&gt; ToLongFunction(java.util.function.Function<Long,Long>: op) -&gt; Object</li>
<li>long -&gt; ToLongFunction(java.util.function.LongToIntFunction: op) -&gt; Object</li>
<li>long -&gt; ToLongFunction(java.util.function.LongToDoubleFunction: op) -&gt; Object</li>
<li>long -&gt; ToLongFunction(java.util.function.LongFunction&lt;?&gt;: func) -&gt; Object</li>
</ul>

<h2 id="tolongunaryoperator">ToLongUnaryOperator</h2>

<p>Adapts any compatible FunctionalInterface type to a LongUnaryOperator,
for use with higher-order functions, when they require a
LongUnaryOperator as an argument. Some of the higher-order functions within
this library specifically require a LongUnaryOperator as an argument, while
some of the other functions are provided in semantically equivalent
forms with compatible types which can&rsquo;t be converted directly or
automatically by Java.</p>

<p>In such cases, those types of functions can be wrapped with the forms
described here in order to allow the inner and outer functions to work together.</p>

<ul>
<li>long -&gt; ToLongUnaryOperator(java.util.function.LongFunction<Long>: f) -&gt; long</li>
<li>long -&gt; ToLongUnaryOperator(java.util.function.Function<Long,Long>: f) -&gt; long</li>
<li>long -&gt; ToLongUnaryOperator(java.util.function.LongUnaryOperator: f) -&gt; long</li>
</ul>

<h2 id="toshort">ToShort</h2>

<p>Convert the input value to a short.</p>

<ul>
<li>double -&gt; ToShort() -&gt; Short</li>
<li>double -&gt; ToShort(int: modulo) -&gt; Short</li>
<li>Float -&gt; ToShort() -&gt; Short</li>
<li>Float -&gt; ToShort(int: modulo) -&gt; Short</li>
<li>int -&gt; ToShort() -&gt; Short</li>
<li>int -&gt; ToShort(int: scale) -&gt; Short</li>
<li>long -&gt; ToShort() -&gt; Short</li>
<li>long -&gt; ToShort(int: wrapat) -&gt; Short

<ul>
<li><em>notes:</em> This form allows for limiting the short values at a lower limit than Short.MAX_VALUE.</li>
</ul></li>
<li>String -&gt; ToShort() -&gt; Short</li>
</ul>

<h2 id="tostring">ToString</h2>

<ul>
<li>Object -&gt; ToString() -&gt; String</li>
<li>Float -&gt; ToString() -&gt; String</li>
<li>int -&gt; ToString() -&gt; String</li>
<li>long -&gt; ToString() -&gt; String</li>
</ul>

<h2 id="touuid">ToUUID</h2>

<p>This function creates a non-random UUID in the type 4 version (Random).
It always puts the same value in the MSB position of the UUID format.
The input value is put in the LSB position.</p>

<pre><code>xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
mmmmmmmm-mmmm-Mmmm-Llll-llllllllllll
              4    3
</code></pre>

<p>As shown above, the LSB position does not have the complication of having
a version identifier (position M) dividing the dynamic range of the data type.
For this reason, only the LSB side is used for this mapper, which allows
an effective range of Long.MAX_VALUE/8, given the loss of 3 digits of precision.</p>

<p>This function is suitable for deterministic testing of scenarios which depend
on type 4 UUIDs, but without the mandated randomness that makes testing difficult.
Just be aware that the MSB will always contain value 0x0123456789ABCDEFL unless you
specify a different long value to pre-fill it with.</p>

<ul>
<li>long -&gt; ToUUID() -&gt; java.util.UUID</li>
<li>long -&gt; ToUUID(long: msbs) -&gt; java.util.UUID</li>
</ul>

<h2 id="triangular">Triangular</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Triangular_distribution">Wikipedia: Triangular distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/TriangularDistribution.html">Commons JavaDoc: TriangularDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Triangular(double: a, double: c, double: b, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Triangular(double: a, double: c, double: b, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="typeof">TypeOf</h2>

<p>Yields the class of the resulting type in String form.</p>

<ul>
<li>Object -&gt; TypeOf() -&gt; String</li>
</ul>

<h2 id="uniform">Uniform</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">Wikipedia: Uniform distribution (continuous)</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/UniformContinuousDistribution.html">Commons JavaDoc: UniformContinuousDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Uniform(double: lower, double: upper, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Uniform(double: lower, double: upper, String[]&hellip;: mods) -&gt; double</li>
<li>int -&gt; Uniform(int: lower, int: upper, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Uniform(int: lower, int: upper, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Uniform(int: lower, int: upper, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Uniform(int: lower, int: upper, String[]&hellip;: modslist) -&gt; long</li>
</ul>

<h2 id="weibull">Weibull</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Weibull_distribution">Wikipedia: Weibull distribution</a>
@see <a href="http://mathworld.wolfram.com/WeibullDistribution.html">Wolfram Mathworld: Weibull Distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/WeibullDistribution.html">Commons Javadoc: WeibullDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Weibull(double: alpha, double: beta, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Weibull(double: alpha, double: beta, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="weightedstrings">WeightedStrings</h2>

<ul>
<li>long -&gt; WeightedStrings(String: valuesAndWeights) -&gt; String</li>
<li>long -&gt; WeightedStrings(String: valueColumn, String: weightColumn, String[]&hellip;: filenames) -&gt; String

<ul>
<li><em>notes:</em> Create a sampler of strings from the given CSV file. The CSV file must have plain CSV headers
as its first line.</li>
</ul></li>
</ul>

<h2 id="zipf">Zipf</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Zipf's_law">Wikipedia: Zipf&rsquo;s Law</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ZipfDistribution.html">Commons JavaDoc: ZipfDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function based on inverse cumulative
 density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Zipf(int: numberOfElements, double: exponent, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Zipf(int: numberOfElements, double: exponent, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Zipf(int: numberOfElements, double: exponent, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Zipf(int: numberOfElements, double: exponent, String[]&hellip;: modslist) -&gt; long</li>
</ul>


			<aside class="copyright" role="note">
				
				&copy; 2018 APL 2.0 &ndash;
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				

<nav class="pagination" aria-label="Footer">
  <div class="previous">
  
      <a href="http://docs.virtdata.io/functions/funcref_distributions/" title="distributions">
        <span class="direction">
          Previous
        </span>
        <div class="page">
          <div class="button button-previous" role="button" aria-label="Previous">
            <i class="icon icon-back"></i>
          </div>
          <div class="stretch">
            <div class="title">
              distributions
            </div>
          </div>
        </div>
      </a>
  
  </div>

  <div class="next">
  
      <a href="http://docs.virtdata.io/functions/funcref_premade/" title="premade">
        <span class="direction">
          Next
        </span>
        <div class="page">
          <div class="stretch">
            <div class="title">
              premade
            </div>
          </div>
          <div class="button button-next" role="button" aria-label="Next">
            <i class="icon icon-forward"></i>
          </div>
        </div>
      </a>
  
  </div>
</nav>





			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '';
      var repo_id  = '';
    
    </script>

    <script src="http://docs.virtdata.io/javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "";
            headers[i].appendChild(a);
        }
      }
    </script>

    

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

