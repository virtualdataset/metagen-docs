<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>All Functions - VirtualDataSet</title>
    <meta name="generator" content="Hugo 0.31" />

    
    <meta name="description" content="VirtualDataSet Docs">
    
    <link rel="canonical" href="http://docs.virtdata.io/functions/autodoc_reference/">
    

    <meta property="og:url" content="http://docs.virtdata.io/functions/autodoc_reference/">
    <meta property="og:title" content="VirtualDataSet">
    <meta property="og:image" content="/images/virtdata_128.png">
    <meta name="apple-mobile-web-app-title" content="VirtualDataSet">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="http://docs.virtdata.io/images/engineblock_32.png">
    <link rel="icon" type="image/x-icon" href="http://docs.virtdata.io/images/engineblock_32.png">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('/fonts/icon.eot?52m981');
        src: url('/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
             url('/fonts/icon.woff?52m981')
               format('woff'),
             url('/fonts/icon.ttf?52m981')
               format('truetype'),
             url('/fonts/icon.svg?52m981#icon')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/application.css">
    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/temporary.css">
    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/palettes.css">
    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/images.css">

    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:400,700|Roboto&#43;Mono">
    <style>
      body, input {
        font-family: 'Roboto', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Roboto Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="http://docs.virtdata.io/javascripts/modernizr.js"></script>

    

  
    

    

    
    

    
    

    
    

    
    

    
    

    
    

    
    
    
    
    

    
    


  </head>
  <body class="palette-primary-grey palette-accent-teal">




<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        All Functions
      </div>
    </div>

    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/virtualdataset/metagen-java" title="@virtualdataset/metagen-java on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="http://docs.virtdata.io/" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="http://docs.virtdata.io/images/virtdata_128.png">
        </div>
      
      <div class="name">
        <strong>VirtualDataSet </strong>
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      

      <div class="toc">
        
        <ul>
          




<li>
  
    <span class="section">Introduction</span>
    <ul>
      
        
        



<a  title="Why VirtData?" href="http://docs.virtdata.io/why_virtdata/why_virtdata/">
	
	Why VirtData?
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Concepts</span>
    <ul>
      
        
        



<a  title="Mapping Functions" href="http://docs.virtdata.io/concepts/mapping_functions/">
	
	Mapping Functions
</a>



      
        
        



<a  title="Function Graphs" href="http://docs.virtdata.io/concepts/function_graphs/">
	
	Function Graphs
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Modeling Datasets</span>
    <ul>
      
        
        



<a  title="Cardinality" href="http://docs.virtdata.io/modeling_datasets/modeling_cardinality/">
	
	Cardinality
</a>



      
        
        



<a  title="Set Relationships" href="http://docs.virtdata.io/modeling_datasets/set_relationships/">
	
	Set Relationships
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Syntax Reference</span>
    <ul>
      
        
        



<a  title="Syntax Reference" href="http://docs.virtdata.io/syntax/syntax_overview/">
	
	Syntax Reference
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Function Reference</span>
    <ul>
      
        
        



<a  title="All Functions" href="http://docs.virtdata.io/functions/autodoc_reference/">
	
	All Functions
</a>



      
    </ul>
  
</li>


        </ul>
        

        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1>All Functions </h1>

			

<h2 id="add">Add</h2>

<ul>
<li>long -&gt; Add(long: addend) -&gt; long</li>
<li>int -&gt; Add(int: addend) -&gt; int

<ul>
<li><em>example:</em> Add(23) <em>adds integer 23 to the input integer value</em></li>
</ul></li>
<li>long -&gt; Add(long: addend) -&gt; int</li>
<li>double -&gt; Add(double: addend) -&gt; double</li>
</ul>

<p>Adds a value to the input.</p>

<h2 id="addcyclerange">AddCycleRange</h2>

<ul>
<li>long -&gt; AddCycleRange(long: maxValue) -&gt; int</li>
<li>long -&gt; AddCycleRange(long: minValue, long: maxValue) -&gt; int</li>
<li>int -&gt; AddCycleRange(int: maxValue) -&gt; int</li>
<li>int -&gt; AddCycleRange(int: minValue, int: maxValue) -&gt; int</li>
<li>long -&gt; AddCycleRange(long: maxValue) -&gt; long</li>
<li>long -&gt; AddCycleRange(long: minValue, long: maxValue) -&gt; long</li>
</ul>

<h2 id="addhashrange">AddHashRange</h2>

<ul>
<li>long -&gt; AddHashRange(long: maxValue) -&gt; int</li>
<li>long -&gt; AddHashRange(long: minValue, long: maxValue) -&gt; int</li>
<li>long -&gt; AddHashRange(long: maxValue) -&gt; long</li>
<li>long -&gt; AddHashRange(long: minValue, long: maxValue) -&gt; long</li>
<li>int -&gt; AddHashRange(int: maxValue) -&gt; int</li>
<li>int -&gt; AddHashRange(int: minValue, int: maxValue) -&gt; int</li>
</ul>

<h2 id="aliaselementsampler">AliasElementSampler</h2>

<ul>
<li>double -&gt; AliasElementSampler(double[]: biases, T[]: elements) -&gt; T</li>
<li>double -&gt; AliasElementSampler(java.util.Collection<T>: elements, java.util.function.Function<T,Double>: weightFunction) -&gt; T</li>
<li>double -&gt; AliasElementSampler(java.util.List<io.virtdata.stathelpers.ElemProbD<T>&gt;: events) -&gt; T</li>
</ul>

<p>Uses the alias sampling method to encode and sample from discrete probabilities,
even over larger sets of data. This form requires a unit interval sample value
between 0.0 and 1.0. Assuming the maximal amount of memory is used for distinct
outcomes N, a memory buffer of N*16 bytes is required for this implementation,
requiring 32MB of memory for 1M entries. Not bad, eh?</p>

<p>This sampler should be shared between threads, and will be by default, in order
to avoid many instances of a 32MB buffer on heap.</p>

<h2 id="aliassamplerdoubleint">AliasSamplerDoubleInt</h2>

<ul>
<li>double -&gt; AliasSamplerDoubleInt(java.nio.ByteBuffer: stats) -&gt; int</li>
<li>double -&gt; AliasSamplerDoubleInt(java.util.List<io.virtdata.stathelpers.EvProbD>: events) -&gt; int</li>
</ul>

<p>Uses the alias sampling method to encode and sample from discrete probabilities,
even over larger sets of data. This form requires a unit interval sample value
between 0.0 and 1.0. Assuming the maximal amount of memory is used for distinct
outcomes N, a memory buffer of N*16 bytes is required for this implementation,
requiring 32MB of memory for 1M entries. Not bad, eh?</p>

<p>This sampler should be shared between threads, and will be by default, in order
to avoid many instances of a 32MB buffer on heap.</p>

<h2 id="alphanumericstring">AlphaNumericString</h2>

<ul>
<li>long -&gt; AlphaNumericString(int: length) -&gt; String</li>
</ul>

<h2 id="clear">Clear</h2>

<ul>
<li>long -&gt; Clear() -&gt; long</li>
<li>long -&gt; Clear(String[]: names) -&gt; long</li>
</ul>

<h2 id="combinations">Combinations</h2>

<ul>
<li>long -&gt; Combinations(String: spec) -&gt; String

<ul>
<li><em>example:</em> Combinations(&lsquo;A-Z;A-Z&rsquo;) <em>a two digit alphanumeric code. Wraps at 26^2</em></li>
<li><em>example:</em> Combinations(&lsquo;0-9A-F&rsquo;) <em>a single hexadecimal digit</em></li>
<li><em>example:</em> Combinations(&lsquo;0123456789ABCDEF&rsquo;) <em>a single hexadecimal digit</em></li>
<li><em>example:</em> Combinations(&lsquo;0-9A-F;0-9A-F;0-9A-F;0-9A-F;&rsquo;) <em>two bytes of hexadecimal</em></li>
<li><em>example:</em> Combinations(&lsquo;A-9&rsquo;) <em>upper case alphanumeric</em></li>
</ul></li>
</ul>

<p>Convert a numeric value into a code according to ASCII printable
characters. This is useful for creating various encodings using different
character ranges, etc.</p>

<p>This mapper can map over the sequences of character ranges providing every unique
combination and then wrapping around to the beginning again.
It can convert between character bases with independent radix in each position.
Each position in the final string takes its values from a position-specific
character set, described by the shorthand in the examples below.</p>

<p>The constructor will throw an error if the number of combinations exceeds that
which can be represented in a long value. (This is a very high
number).</p>

<h2 id="cyclerange">CycleRange</h2>

<ul>
<li>long -&gt; CycleRange(long: maxValue) -&gt; long</li>
<li>long -&gt; CycleRange(long: minValue, long: maxValue) -&gt; long</li>
<li>long -&gt; CycleRange(long: maxValue) -&gt; int</li>
<li>long -&gt; CycleRange(long: minValue, long: maxValue) -&gt; int</li>
<li>int -&gt; CycleRange(int: maxValue) -&gt; int</li>
<li>int -&gt; CycleRange(int: minValue, int: maxValue) -&gt; int</li>
</ul>

<h2 id="datetimeformats">DateTimeFormats</h2>

<ul>
<li>null -&gt; DateTimeFormats() -&gt; null</li>
</ul>

<p>The valid formats, in joda specifier form are documented in DateTimeFormats
<ol>
<li>yyyy-MM-dd HH:mm:ss.SSSZ, for example: 2015-02-28 23:30:15.223</li>
<li>yyyy-MM-dd HH:mm:ss, for example 2015-02-28 23:30:15</li>
<li>yyyyMMdd&rsquo;T&rsquo;HHmmss.SSSZ, for example: 20150228T233015.223</li>
<li>yyyyMMdd&rsquo;T&rsquo;HHmmssZ, for example: 20150228T233015</li>
<li>yyyy-MM-dd, for example: 2015-02-28</li>
<li>yyyyMMdd, for example: 20150228</li>
<li>yyyyMM, for example: 201502</li>
<li>yyyy, for example: 2015</li>
</ol></p>

<h2 id="directorylines">DirectoryLines</h2>

<ul>
<li>long -&gt; DirectoryLines(String: basepath, String: namePattern) -&gt; String</li>
</ul>

<h2 id="div">Div</h2>

<ul>
<li>long -&gt; Div(int: divisor) -&gt; int</li>
<li>int -&gt; Div(int: divisor) -&gt; int</li>
<li>long -&gt; Div(int: divisor) -&gt; long</li>
<li>double -&gt; Div(double: divisor) -&gt; double</li>
</ul>

<h2 id="dividetolongtostring">DivideToLongToString</h2>

<ul>
<li>long -&gt; DivideToLongToString(long: divisor) -&gt; String</li>
</ul>

<p>Integer devide the cycle, the other side of modulo.</p>

<h2 id="doubletofloat">DoubleToFloat</h2>

<ul>
<li>double -&gt; DoubleToFloat() -&gt; Float</li>
</ul>

<h2 id="expr">Expr</h2>

<ul>
<li>int -&gt; Expr(String: expr) -&gt; int</li>
<li>long -&gt; Expr(String: expr) -&gt; int</li>
<li>double -&gt; Expr(String: expr) -&gt; double</li>
<li>long -&gt; Expr(String: expr) -&gt; long</li>
</ul>

<h2 id="femalefirstnames">FemaleFirstNames</h2>

<ul>
<li>null -&gt; FemaleFirstNames() -&gt; null</li>
</ul>

<h2 id="fieldextractor">FieldExtractor</h2>

<ul>
<li>String -&gt; FieldExtractor(String: fields) -&gt; String</li>
</ul>

<p>Extracts out a set of fields from a delimited string, returning
a string with the same delimiter containing only the specified fields.</p>

<h2 id="firstnames">FirstNames</h2>

<ul>
<li>null -&gt; FirstNames() -&gt; null</li>
</ul>

<h2 id="fixedvalue">FixedValue</h2>

<ul>
<li>long -&gt; FixedValue(int: value) -&gt; int</li>
<li>long -&gt; FixedValue(long: fixedValue) -&gt; long</li>
</ul>

<h2 id="fixedvalues">FixedValues</h2>

<ul>
<li>long -&gt; FixedValues(long[]: values) -&gt; long</li>
<li>long -&gt; FixedValues(int[]: values) -&gt; int</li>
</ul>

<h2 id="format">Format</h2>

<ul>
<li>Object -&gt; Format(String: format) -&gt; String</li>
</ul>

<h2 id="fullhash">FullHash</h2>

<ul>
<li>long -&gt; FullHash() -&gt; long</li>
</ul>

<p>This uses the Murmur3F (64-bit optimized) version of Murmur3,
not as a checksum, but as a simple hash. It doesn&rsquo;t bother
pushing the high-64 bits of input, since it only uses the lower
64 bits of output.</p>

<p>This version returns the value regardless of this sign bit.
It does not return the absolute value, as Hash does.</p>

<h2 id="fullnames">FullNames</h2>

<ul>
<li>null -&gt; FullNames() -&gt; null</li>
</ul>

<h2 id="functemplate">FuncTemplate</h2>

<ul>
<li>long -&gt; FuncTemplate(String: rawTemplate) -&gt; String</li>
</ul>

<h2 id="hash">Hash</h2>

<ul>
<li>long -&gt; Hash() -&gt; long</li>
<li>int -&gt; Hash() -&gt; int</li>
<li>long -&gt; Hash() -&gt; int</li>
</ul>

<p>This uses the Murmur3F (64-bit optimized) version of Murmur3,
not as a checksum, but as a simple hash. It doesn&rsquo;t bother
pushing the high-64 bits of input, since it only uses the lower
64 bits of output. It does, however, return the absolute value.
This is to make it play nice with users and other libraries.</p>

<h2 id="hashrange">HashRange</h2>

<ul>
<li>long -&gt; HashRange(long: width) -&gt; long</li>
<li>long -&gt; HashRange(long: minValue, long: maxValue) -&gt; long</li>
<li>int -&gt; HashRange(int: width) -&gt; int</li>
<li>int -&gt; HashRange(int: minValue, int: maxValue) -&gt; int</li>
<li>long -&gt; HashRange(long: width) -&gt; int</li>
<li>long -&gt; HashRange(long: minValue, long: maxValue) -&gt; int</li>
</ul>

<h2 id="hashrangescaled">HashRangeScaled</h2>

<ul>
<li>long -&gt; HashRangeScaled() -&gt; int</li>
<li>long -&gt; HashRangeScaled() -&gt; long</li>
<li>int -&gt; HashRangeScaled() -&gt; int</li>
</ul>

<p>Uses the input value as well to establish the upper bound of the
value produced from the hash.</p>

<h2 id="hasheddoublerange">HashedDoubleRange</h2>

<ul>
<li>long -&gt; HashedDoubleRange(double: min, double: max) -&gt; double</li>
</ul>

<p>This simulates a uniform sample from a range of double values
via long hashing. This function attempts to take a double
unit interval value from a long/long division over the whole
range of long values but via double value types, thus providing
a very linear sample. This means that the range of double
values to be accessed will not fall along all possible doubles,
but will still provide suitable values for ranges close to
high-precision points in the IEEE floating point number line.
This suffices for most reasonable ranges in practice outside
of scientific computing, where large exponents put adjacent
IEEE floating point values much further apart.</p>

<p>This should be consider the default double range sampling
function for most uses, when the exponent is not needed for
readability.</p>

<h2 id="hashedfileextracttostring">HashedFileExtractToString</h2>

<ul>
<li>long -&gt; HashedFileExtractToString(String: fileName, int: minsize, int: maxsize) -&gt; String</li>
</ul>

<h2 id="hashedlinetoint">HashedLineToInt</h2>

<ul>
<li>long -&gt; HashedLineToInt(String: filename) -&gt; int</li>
</ul>

<h2 id="hashedlinetostring">HashedLineToString</h2>

<ul>
<li>long -&gt; HashedLineToString(String: filename) -&gt; String</li>
</ul>

<h2 id="hashedlinetostringlist">HashedLineToStringList</h2>

<ul>
<li>long -&gt; HashedLineToStringList(String: filename, int: minSize, int: maxSize) -&gt; java.util.List</li>
</ul>

<h2 id="hashedlinetostringset">HashedLineToStringSet</h2>

<ul>
<li>long -&gt; HashedLineToStringSet(String: filename, int: minSize, int: maxSize) -&gt; java.util.Set<String></li>
</ul>

<h2 id="hashedlinetostringstringmap">HashedLineToStringStringMap</h2>

<ul>
<li>long -&gt; HashedLineToStringStringMap(String: paramFile, int: maxSize) -&gt; java.util.Map<String,String></li>
</ul>

<h2 id="hashedlinestokeyvaluestring">HashedLinesToKeyValueString</h2>

<ul>
<li>long -&gt; HashedLinesToKeyValueString(String: paramFile, int: maxsize) -&gt; String</li>
</ul>

<h2 id="hashedloremextracttostring">HashedLoremExtractToString</h2>

<ul>
<li>long -&gt; HashedLoremExtractToString(int: minsize, int: maxsize) -&gt; String</li>
</ul>

<h2 id="hashedrangedtononuniformdouble">HashedRangedToNonuniformDouble</h2>

<ul>
<li>null -&gt; HashedRangedToNonuniformDouble(long: min, long: max) -&gt; null</li>
<li>null -&gt; HashedRangedToNonuniformDouble(long: min, long: max, long: seed) -&gt; null</li>
</ul>

<p>This provides a random sample of a double in a range, without
accounting for the non-uniform distribution of IEEE double representation.
This means that values closer to high-precision areas of the IEEE spec
will be weighted higher in the output. However, NaN and positive and
negative infinity are filtered out via oversampling. Results are still
stable for a given input value.</p>

<h2 id="hashedtobytebuffer">HashedToByteBuffer</h2>

<ul>
<li>long -&gt; HashedToByteBuffer(int: lengthInBytes) -&gt; java.nio.ByteBuffer</li>
</ul>

<p>Hash a long input value into a byte buffer, at least length bytes long, but aligned on 8-byte
boundary;</p>

<h2 id="identity">Identity</h2>

<ul>
<li>long -&gt; Identity() -&gt; long</li>
</ul>

<h2 id="interpolate">Interpolate</h2>

<ul>
<li>long -&gt; Interpolate(double[]: value) -&gt; long

<ul>
<li><em>example:</em> Interpolate(0.0d,100.0d) <em>return a linear value between 0L and 100L based on input in range 0L, Long.MAX_VALUE</em></li>
<li><em>example:</em> Interpolate(0.0d,90.0d,95.0d,98.0d,100.0d) <em>return a weighted value between 0L and 100L based on input in range 0L, Long.MAX_VALUE, where the first second and third quartiles map to 90.0D, 95.0D, and 98.0D</em></li>
</ul></li>
<li>long -&gt; Interpolate(long[]: value) -&gt; long</li>
<li>long -&gt; Interpolate(int: resolution, double[]: lut) -&gt; long</li>
<li>long -&gt; Interpolate(double[]: value) -&gt; double

<ul>
<li><em>example:</em> Interpolate(0.0d,100.0d) // return a linear value, 0L -&gt; 0.0D, Long.MAX_VALUE -&gt; 100.0D</li>
<li><em>example:</em> Interpolate(0.0d,90.0d,95.0d,98.0d,100.0d) <em>return a weighted value between 0.0D and 100.0D based on input in range 0L, Long.MAX_VALUE, where the first second and third quartiles map to 90.0D, 95.0D, and 98.0D</em></li>
</ul></li>
<li>long -&gt; Interpolate(int: resolution, double[]: lut) -&gt; double</li>
</ul>

<h2 id="jointemplate">JoinTemplate</h2>

<ul>
<li>null -&gt; JoinTemplate(String: delimiter, java.util.function.LongFunction&lt;?&gt;[]: funcs) -&gt; null</li>
<li>null -&gt; JoinTemplate(String: prefix, String: delimiter, String: suffix, java.util.function.LongFunction&lt;?&gt;[]: funcs) -&gt; null</li>
<li>null -&gt; JoinTemplate(java.util.function.LongUnaryOperator: iterop, String: prefix, String: delimiter, String: suffix, java.util.function.LongFunction&lt;?&gt;[]: funcs) -&gt; null</li>
</ul>

<h2 id="lastnames">LastNames</h2>

<ul>
<li>null -&gt; LastNames() -&gt; null</li>
</ul>

<h2 id="listtemplate">ListTemplate</h2>

<ul>
<li>long -&gt; ListTemplate(java.util.function.LongToIntFunction: sizeFunc, java.util.function.LongFunction<String>: valueFunc) -&gt; java.util.List<String></li>
</ul>

<h2 id="load">Load</h2>

<ul>
<li>long -&gt; Load(String: name) -&gt; long</li>
<li>int -&gt; Load(String: name) -&gt; int</li>
<li>Object -&gt; Load(String: name) -&gt; Object</li>
<li>double -&gt; Load(String: name) -&gt; double</li>
<li>String -&gt; Load(String: name) -&gt; String</li>
</ul>

<h2 id="longtobyte">LongToByte</h2>

<ul>
<li>long -&gt; LongToByte() -&gt; Byte</li>
</ul>

<h2 id="longtoshort">LongToShort</h2>

<ul>
<li>long -&gt; LongToShort() -&gt; Short</li>
</ul>

<h2 id="longtostring">LongToString</h2>

<ul>
<li>long -&gt; LongToString() -&gt; String</li>
</ul>

<h2 id="malefirstnames">MaleFirstNames</h2>

<ul>
<li>null -&gt; MaleFirstNames() -&gt; null</li>
</ul>

<h2 id="maptemplate">MapTemplate</h2>

<ul>
<li>long -&gt; MapTemplate(java.util.function.LongToIntFunction: sizeFunc, java.util.function.LongFunction<String>: keyFunc, java.util.function.LongFunction<String>: valueFunc) -&gt; java.util.Map<String,String></li>
</ul>

<h2 id="max">Max</h2>

<ul>
<li>long -&gt; Max(long: max) -&gt; long

<ul>
<li><em>example:</em> Max(42L) <em>take the value of 42L or the input, which ever is greater</em></li>
<li><em>example:</em> Max(-42L) <em>take the value of -42L or the input, which ever is greater</em></li>
</ul></li>
<li>int -&gt; Max(int: max) -&gt; int</li>
<li>double -&gt; Max(double: max) -&gt; double</li>
</ul>

<h2 id="min">Min</h2>

<ul>
<li>long -&gt; Min(long: min) -&gt; long</li>
<li>int -&gt; Min(int: min) -&gt; int</li>
<li>double -&gt; Min(double: min) -&gt; double</li>
</ul>

<h2 id="mod">Mod</h2>

<ul>
<li>int -&gt; Mod(int: modulo) -&gt; int</li>
<li>long -&gt; Mod(long: modulo) -&gt; int</li>
<li>long -&gt; Mod(long: modulo) -&gt; long</li>
</ul>

<h2 id="modulolinetostring">ModuloLineToString</h2>

<ul>
<li>long -&gt; ModuloLineToString(String: filename) -&gt; String</li>
</ul>

<h2 id="modulotobigdecimal">ModuloToBigDecimal</h2>

<ul>
<li>long -&gt; ModuloToBigDecimal() -&gt; java.math.BigDecimal</li>
<li>long -&gt; ModuloToBigDecimal(long: modulo) -&gt; java.math.BigDecimal</li>
</ul>

<h2 id="modulotobigint">ModuloToBigInt</h2>

<ul>
<li>long -&gt; ModuloToBigInt() -&gt; java.math.BigInteger</li>
<li>long -&gt; ModuloToBigInt(long: modulo) -&gt; java.math.BigInteger</li>
</ul>

<h2 id="modulotoboolean">ModuloToBoolean</h2>

<ul>
<li>long -&gt; ModuloToBoolean() -&gt; Boolean</li>
</ul>

<h2 id="modulotobyte">ModuloToByte</h2>

<ul>
<li>long -&gt; ModuloToByte(long: modulo) -&gt; Byte</li>
</ul>

<h2 id="modulotointeger">ModuloToInteger</h2>

<ul>
<li>long -&gt; ModuloToInteger(int: modulo) -&gt; Integer</li>
</ul>

<h2 id="modulotolong">ModuloToLong</h2>

<ul>
<li>long -&gt; ModuloToLong(long: modulo) -&gt; long</li>
</ul>

<h2 id="modulotoshort">ModuloToShort</h2>

<ul>
<li>long -&gt; ModuloToShort(long: modulo) -&gt; Short</li>
</ul>

<h2 id="mul">Mul</h2>

<ul>
<li>long -&gt; Mul(long: multiplicand) -&gt; int</li>
<li>double -&gt; Mul(double: factor) -&gt; double</li>
<li>long -&gt; Mul(long: multiplicand) -&gt; long</li>
<li>int -&gt; Mul(int: addend) -&gt; int</li>
</ul>

<h2 id="murmur3divtolong">Murmur3DivToLong</h2>

<ul>
<li>long -&gt; Murmur3DivToLong(long: divisor) -&gt; long</li>
</ul>

<h2 id="murmur3divtostring">Murmur3DivToString</h2>

<ul>
<li>long -&gt; Murmur3DivToString(long: divisor) -&gt; String</li>
</ul>

<h2 id="numbernametostring">NumberNameToString</h2>

<ul>
<li>long -&gt; NumberNameToString() -&gt; String</li>
</ul>

<h2 id="prefix">Prefix</h2>

<ul>
<li>String -&gt; Prefix(String: prefix) -&gt; String</li>
</ul>

<p>Created by sebastianestevez on 8/28/17.</p>

<h2 id="save">Save</h2>

<ul>
<li>String -&gt; Save(String: name) -&gt; String</li>
<li>Object -&gt; Save(String: name) -&gt; Object</li>
<li>long -&gt; Save(String: name) -&gt; long</li>
<li>int -&gt; Save(String: name) -&gt; int</li>
<li>double -&gt; Save(String: name) -&gt; double</li>
</ul>

<h2 id="scale">Scale</h2>

<ul>
<li>long -&gt; Scale(double: scaleFactor) -&gt; long</li>
<li>long -&gt; Scale(double: scaleFactor) -&gt; int</li>
<li>int -&gt; Scale(double: scaleFactor) -&gt; int</li>
</ul>

<p>Scale the input to the</p>

<h2 id="show">Show</h2>

<ul>
<li>Object -&gt; Show() -&gt; String</li>
<li>Object -&gt; Show(String[]: names) -&gt; String</li>
</ul>

<h2 id="shuffle">Shuffle</h2>

<ul>
<li>long -&gt; Shuffle(long: min, long: maxPlusOne) -&gt; long

<ul>
<li><em>example:</em> Shuffle(11,99) <em>Provide all values between 11 and 98 inclusive, in some order, then repeat</em></li>
</ul></li>
<li>long -&gt; Shuffle(long: min, long: maxPlusOne, int: moduloSelector) -&gt; long</li>
</ul>

<p>This function provides a low-overhead shuffling effect without loading
elements into memory. It uses a bundled dataset of pre-computed
Galois LFSR shift register configurations, along with a down-sampling
method to provide amortized virtual shuffling with minimal memory usage.</p>

<h2 id="signedhash">SignedHash</h2>

<ul>
<li>int -&gt; SignedHash() -&gt; int</li>
<li>long -&gt; SignedHash() -&gt; long</li>
<li>long -&gt; SignedHash() -&gt; int</li>
</ul>

<h2 id="startingepochmillis">StartingEpochMillis</h2>

<ul>
<li>long -&gt; StartingEpochMillis(String: baseTimeSpec) -&gt; long

<ul>
<li><em>example:</em> {StartingEpochMillis(&lsquo;2017-01-01 23:59:59&rsquo;)} <em>add the millisecond epoch time of 2017-01-01 23:59:59 to all input values</em></li>
</ul></li>
</ul>

<p>This function sets the minimum long value to the equivalent
unix epoch time in milliseconds. It simply adds the input
value to this base value as determined by the provided
time specifier. It wraps any overflow within this range as well.</p>

<h2 id="staticstringmapper">StaticStringMapper</h2>

<ul>
<li>long -&gt; StaticStringMapper(String: string) -&gt; String</li>
</ul>

<h2 id="stringdatewrapper">StringDateWrapper</h2>

<ul>
<li>long -&gt; StringDateWrapper(String: format) -&gt; String</li>
</ul>

<h2 id="suffix">Suffix</h2>

<ul>
<li>String -&gt; Suffix(String: suffix) -&gt; String</li>
</ul>

<h2 id="template">Template</h2>

<ul>
<li>long -&gt; Template(String: template, java.util.function.LongFunction&lt;?&gt;[]: funcs) -&gt; String</li>
<li>long -&gt; Template(java.util.function.LongUnaryOperator: iterOp, String: template, java.util.function.LongFunction&lt;?&gt;[]: funcs) -&gt; String</li>
</ul>

<p>Creates a template function which will yield a string which fits the template
provided, with all occurrences of <code>{}</code> substituted pair-wise with the
result of the provided function. The number of <code>{}</code> entries in the template
must strictly match the number of functions or an error will be thrown.
To provide differing values for similarly defined functions in the list, the input
value used is automatically incremented by one for each function, starting with
the initial input value.</p>

<h2 id="threadnumtointeger">ThreadNumToInteger</h2>

<ul>
<li>long -&gt; ThreadNumToInteger() -&gt; Integer</li>
</ul>

<p>Matches a digit sequence in the current thread name and caches it in a thread local.
This allows you to use any intentionally indexed thread factories to provide an analogue for
concurrency. Note that once the thread number is cached, it will not be refreshed. This means
you can&rsquo;t change the thread name and get an updated value.</p>

<h2 id="threadnumtolong">ThreadNumToLong</h2>

<ul>
<li>long -&gt; ThreadNumToLong() -&gt; long</li>
</ul>

<p>Matches a digit sequence in the current thread name and caches it in a thread local.
This allows you to use any intentionally indexed thread factories to provide an analogue for
concurrency. Note that once the thread number is cached, it will not be refreshed. This means
you can&rsquo;t change the thread name and get an updated value.</p>

<h2 id="tobigint">ToBigInt</h2>

<ul>
<li>long -&gt; ToBigInt() -&gt; java.math.BigInteger</li>
</ul>

<h2 id="toboolean">ToBoolean</h2>

<ul>
<li>Double -&gt; ToBoolean() -&gt; Boolean</li>
<li>Float -&gt; ToBoolean() -&gt; Boolean</li>
<li>Integer -&gt; ToBoolean() -&gt; Boolean</li>
<li>long -&gt; ToBoolean() -&gt; Boolean</li>
</ul>

<h2 id="tobyte">ToByte</h2>

<ul>
<li>double -&gt; ToByte() -&gt; Byte</li>
<li>double -&gt; ToByte(int: modulo) -&gt; Byte</li>
<li>Float -&gt; ToByte() -&gt; Byte</li>
<li>Float -&gt; ToByte(int: modulo) -&gt; Byte</li>
<li>long -&gt; ToByte() -&gt; Byte</li>
<li>long -&gt; ToByte(int: modulo) -&gt; Byte</li>
<li>String -&gt; ToByte() -&gt; Byte</li>
<li>Short -&gt; ToByte(int: scale) -&gt; Byte</li>
<li>Short -&gt; ToByte() -&gt; Byte</li>
<li>int -&gt; ToByte() -&gt; Byte</li>
<li>int -&gt; ToByte(int: modulo) -&gt; Byte</li>
</ul>

<h2 id="tobytebuffer">ToByteBuffer</h2>

<ul>
<li>Float -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>Short -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>long -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>int -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>String -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>double -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
</ul>

<h2 id="todate">ToDate</h2>

<ul>
<li>long -&gt; ToDate(int: spacing, int: repeat_count) -&gt; java.util.Date</li>
<li>long -&gt; ToDate(int: spacing) -&gt; java.util.Date</li>
<li>long -&gt; ToDate() -&gt; java.util.Date</li>
</ul>

<h2 id="todatetime">ToDateTime</h2>

<ul>
<li>long -&gt; ToDateTime(int: spacing, int: repeat_count) -&gt; org.joda.time.DateTime</li>
<li>long -&gt; ToDateTime(String: spacing) -&gt; org.joda.time.DateTime</li>
<li>long -&gt; ToDateTime() -&gt; org.joda.time.DateTime</li>
</ul>

<h2 id="todouble">ToDouble</h2>

<ul>
<li>long -&gt; ToDouble() -&gt; double</li>
</ul>

<h2 id="toepochtimeuuid">ToEpochTimeUUID</h2>

<ul>
<li>long -&gt; ToEpochTimeUUID() -&gt; java.util.UUID

<ul>
<li><em>example:</em> ToEpochTimeUUID() <em>basetime 0, computed node data, empty clock data</em></li>
</ul></li>
<li>long -&gt; ToEpochTimeUUID(long: node) -&gt; java.util.UUID

<ul>
<li><em>example:</em> ToEpochTimeUUID(5234) <em>basetime 0, specified node data (5234), empty clock data</em></li>
</ul></li>
<li>long -&gt; ToEpochTimeUUID(long: node, long: clock) -&gt; java.util.UUID

<ul>
<li><em>example:</em> ToEpochTimeUUID(31,337) <em>basetime 0, specified node data (31) and clock data (337)</em></li>
</ul></li>
<li>long -&gt; ToEpochTimeUUID(String: baseSpec) -&gt; java.util.UUID

<ul>
<li><em>example:</em> ToEpochTimeUUID(&lsquo;2017-01-01T23:59:59&rsquo;) <em>specified basetime, computed node data, empty clock data</em></li>
</ul></li>
<li>long -&gt; ToEpochTimeUUID(String: baseSpec, long: node) -&gt; java.util.UUID

<ul>
<li><em>example:</em> ToEpochTimeUUID(&lsquo;2012&rsquo;,12345) <em>basetime at start if 2012, with node data 12345, empty clock data</em></li>
</ul></li>
<li>long -&gt; ToEpochTimeUUID(String: baseSpec, long: node, long: clock) -&gt; java.util.UUID

<ul>
<li><em>example:</em> ToEpochTimeUUID(&lsquo;20171231T1015.243&rsquo;,123,456) <em>ms basetime, specified node and clock data</em></li>
</ul></li>
</ul>

<p>Converts a long UTC timestamp in epoch millis form into a Version 1 TimeUUID
according to <a href="https://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a>.
This means that only one unique value for a timeuuid can be generated for
each epoch milli value, even though version 1 TimeUUIDs can normally represent
up to 10000 distinct values per millisecond. If you need to access this
level of resolution for testing purposes, use ToFinestTimeUUID
instead. This method is to support simple mapping to natural timestamps
as we often find in the real world.</p>

<p>For the variants that have an String argument in the constructor, this is
a parsable datetime that is used as the base time for all produced values.
Setting this allows you to set the start of the time range for all timeuuid
values produced. All times are parsed for UTC. All time use ISO date ordering,
meaning that the most significant fields always go before the others.</p>

<p>The valid formats, in joda specifier form are:
<ol>
<li>yyyy-MM-dd HH:mm:ss.SSSZ, for example: 2015-02-28 23:30:15.223</li>
<li>yyyy-MM-dd HH:mm:ss, for example 2015-02-28 23:30:15</li>
<li>yyyyMMdd&rsquo;T&rsquo;HHmmss.SSSZ, for example: 20150228T233015.223</li>
<li>yyyyMMdd&rsquo;T&rsquo;HHmmssZ, for example: 20150228T233015</li>
<li>yyyy-MM-dd, for example: 2015-02-28</li>
<li>yyyyMMdd, for example: 20150228</li>
<li>yyyyMM, for example: 201502</li>
<li>yyyy, for example: 2015</li>
</ol></p>

<h2 id="tofinesttimeuuid">ToFinestTimeUUID</h2>

<ul>
<li>long -&gt; ToFinestTimeUUID() -&gt; java.util.UUID

<ul>
<li><em>example:</em> ToFinestTimeUUID() <em>basetime 0, computed node data, empty clock data</em></li>
</ul></li>
<li>long -&gt; ToFinestTimeUUID(long: node) -&gt; java.util.UUID

<ul>
<li><em>example:</em> ToFinestTimeUUID(5234) <em>basetime 0, specified node data (5234), empty clock data</em></li>
</ul></li>
<li>long -&gt; ToFinestTimeUUID(long: node, long: clock) -&gt; java.util.UUID

<ul>
<li><em>example:</em> ToFinestTimeUUID(31,337) <em>basetime 0, specified node data (31) and clock data (337)</em></li>
</ul></li>
<li>long -&gt; ToFinestTimeUUID(String: baseTimeSpec) -&gt; java.util.UUID

<ul>
<li><em>example:</em> ToFinestTimeUUID(&lsquo;2017-01-01T23:59:59&rsquo;) <em>specified basetime, computed node data, empty clock data</em></li>
</ul></li>
<li>long -&gt; ToFinestTimeUUID(String: baseTimeSpec, long: node) -&gt; java.util.UUID

<ul>
<li><em>example:</em> ToFinestTimeUUID(&lsquo;2012&rsquo;,12345) <em>basetime at start if 2012, with node data 12345, empty clock data</em></li>
</ul></li>
<li>long -&gt; ToFinestTimeUUID(String: baseTimeSpec, long: node, long: clock) -&gt; java.util.UUID

<ul>
<li><em>example:</em> ToFinestTimeUUID(&lsquo;20171231T1015.243&rsquo;,123,456) <em>ms basetime, specified node and clock data</em></li>
</ul></li>
</ul>

<p>Converts a count of 100ns intervals from 1582 Julian to a Type1 TimeUUID
according to <a href="https://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a>.
This allows you to access the finest unit of resolution for the
purposes of simulating a large set of unique timeuuid values. This offers
10000 times more unique values per ms than ToEpochTimeUUID.</p>

<p>For the variants that have an String argument in the constructor, this is
a parsable datetime that is used as the base time for all produced values.
Setting this allows you to set the start of the time range for all timeuuid
values produced. All times are parsed for UTC. All time use ISO date ordering,
meaning that the most significant fields always go before the others.</p>

<p>The valid formats, in joda specifier form are:</p>

<ol>
<li>yyyy-MM-dd HH:mm:ss.SSSZ, for example: 2015-02-28 23:30:15.223</li>
<li>yyyy-MM-dd HH:mm:ss, for example 2015-02-28 23:30:15</li>
<li>yyyyMMdd'T'HHmmss.SSSZ, for example: 20150228T233015.223</li>
<li>yyyyMMdd'T'HHmmssZ, for example: 20150228T233015</li>
<li>yyyy-MM-dd, for example: 2015-02-28</li>
<li>yyyyMMdd, for example: 20150228</li>
<li>yyyyMM, for example: 201502</li>
<li>yyyy, for example: 2015</li>
</ol>

<h2 id="tofloat">ToFloat</h2>

<ul>
<li>double -&gt; ToFloat(double: scale) -&gt; Float</li>
<li>double -&gt; ToFloat() -&gt; Float</li>
<li>long -&gt; ToFloat(long: scale) -&gt; Float</li>
<li>long -&gt; ToFloat() -&gt; Float</li>
<li>String -&gt; ToFloat() -&gt; Float</li>
<li>int -&gt; ToFloat(int: scale) -&gt; Float</li>
<li>int -&gt; ToFloat() -&gt; Float</li>
<li>Short -&gt; ToFloat() -&gt; Float</li>
</ul>

<h2 id="tohasheduuid">ToHashedUUID</h2>

<ul>
<li>long -&gt; ToHashedUUID() -&gt; java.util.UUID</li>
</ul>

<p>This function provides a stable hashing of the input value to
a version 4 (Random) UUID.</p>

<h2 id="toinetaddress">ToInetAddress</h2>

<ul>
<li>long -&gt; ToInetAddress() -&gt; java.net.InetAddress</li>
</ul>

<h2 id="toint">ToInt</h2>

<ul>
<li>String -&gt; ToInt() -&gt; Integer</li>
<li>double -&gt; ToInt(int: scale) -&gt; int</li>
<li>double -&gt; ToInt() -&gt; int</li>
<li>long -&gt; ToInt(int: scale) -&gt; int</li>
<li>long -&gt; ToInt() -&gt; int</li>
<li>long -&gt; ToInt() -&gt; int</li>
<li>Double -&gt; ToInt(int: scale) -&gt; Integer</li>
<li>Double -&gt; ToInt() -&gt; Integer</li>
<li>Object -&gt; ToInt() -&gt; Integer</li>
</ul>

<h2 id="tojodadatetime">ToJodaDateTime</h2>

<ul>
<li>long -&gt; ToJodaDateTime(int: spacing, int: repeat_count) -&gt; org.joda.time.DateTime</li>
<li>long -&gt; ToJodaDateTime(String: spacing) -&gt; org.joda.time.DateTime</li>
<li>long -&gt; ToJodaDateTime() -&gt; org.joda.time.DateTime</li>
</ul>

<h2 id="tolong">ToLong</h2>

<ul>
<li>Float -&gt; ToLong(long: scale) -&gt; Long</li>
<li>Float -&gt; ToLong() -&gt; Long</li>
<li>double -&gt; ToLong(long: scale) -&gt; long</li>
<li>double -&gt; ToLong() -&gt; long</li>
</ul>

<h2 id="tolongfunction">ToLongFunction</h2>

<ul>
<li>long -&gt; ToLongFunction(java.util.function.LongUnaryOperator: op) -&gt; Object</li>
<li>long -&gt; ToLongFunction(java.util.function.Function<Long,Long>: op) -&gt; Object</li>
<li>long -&gt; ToLongFunction(java.util.function.LongToIntFunction: op) -&gt; Object</li>
<li>long -&gt; ToLongFunction(java.util.function.LongToDoubleFunction: op) -&gt; Object</li>
<li>long -&gt; ToLongFunction(java.util.function.LongFunction&lt;?&gt;: func) -&gt; Object</li>
</ul>

<p>Adapts any FunctionalInterface type to a LongFunction,
for use with higher-order functions, when they require a
LongFunction as an argument.</p>

<h2 id="tolongunaryoperator">ToLongUnaryOperator</h2>

<ul>
<li>long -&gt; ToLongUnaryOperator(java.util.function.LongFunction<Long>: f) -&gt; long</li>
<li>long -&gt; ToLongUnaryOperator(java.util.function.Function<Long,Long>: f) -&gt; long</li>
<li>long -&gt; ToLongUnaryOperator(java.util.function.LongUnaryOperator: f) -&gt; long</li>
</ul>

<h2 id="toshort">ToShort</h2>

<ul>
<li>double -&gt; ToShort() -&gt; Short</li>
<li>double -&gt; ToShort(int: modulo) -&gt; Short</li>
<li>long -&gt; ToShort() -&gt; Short</li>
<li>long -&gt; ToShort(int: wrapat) -&gt; Short</li>
<li>String -&gt; ToShort() -&gt; Short</li>
<li>Float -&gt; ToShort() -&gt; Short</li>
<li>Float -&gt; ToShort(int: modulo) -&gt; Short</li>
<li>int -&gt; ToShort() -&gt; Short</li>
<li>int -&gt; ToShort(int: scale) -&gt; Short</li>
</ul>

<h2 id="tostring">ToString</h2>

<ul>
<li>Object -&gt; ToString() -&gt; String</li>
</ul>

<h2 id="touuid">ToUUID</h2>

<ul>
<li>long -&gt; ToUUID() -&gt; java.util.UUID</li>
<li>long -&gt; ToUUID(long: msbs) -&gt; java.util.UUID</li>
</ul>

<p>This function creates a non-random UUID in the type 4 version (Random).
It puts the same value in the MSB position of the UUID format.
The input value is put in the LSB position.</p>

<pre><code>xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
mmmmmmmm-mmmm-Mmmm-Llll-llllllllllll
              4    3
</code></pre>

<p>As shown above, the LSB position does not have the complication of having
a version identifier (position M) dividing the dynamic range of the data type.
For this reason, only the LSB side is used for this mapper, which allows
an effective range of Long.MAX_VALUE/8, given the loss of 3 digits of precision.</p>

<h2 id="weightedstrings">WeightedStrings</h2>

<ul>
<li>long -&gt; WeightedStrings(String: valuesAndWeights) -&gt; String</li>
<li>long -&gt; WeightedStrings(String: valueColumn, String: weightColumn, String[]: filenames) -&gt; String</li>
</ul>


			<aside class="copyright" role="note">
				
				&copy; 2018 APL 2.0 &ndash;
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				

<nav class="pagination" aria-label="Footer">
  <div class="previous">
  
      <a href="http://docs.virtdata.io/modeling_datasets/set_relationships/" title="Set Relationships">
        <span class="direction">
          Previous
        </span>
        <div class="page">
          <div class="button button-previous" role="button" aria-label="Previous">
            <i class="icon icon-back"></i>
          </div>
          <div class="stretch">
            <div class="title">
              Set Relationships
            </div>
          </div>
        </div>
      </a>
  
  </div>

  <div class="next">
  
      <a href="http://docs.virtdata.io/functions/functions_reference2/" title="">
        <span class="direction">
          Next
        </span>
        <div class="page">
          <div class="stretch">
            <div class="title">
              
            </div>
          </div>
          <div class="button button-next" role="button" aria-label="Next">
            <i class="icon icon-forward"></i>
          </div>
        </div>
      </a>
  
  </div>
</nav>





			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '';
      var repo_id  = '';
    
    </script>

    <script src="http://docs.virtdata.io/javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "Â¶";
            headers[i].appendChild(a);
        }
      }
    </script>

    

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

