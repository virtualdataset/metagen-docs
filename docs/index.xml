<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>VirtualDataSet</title>
    <link>http://docs.virtdata.io/</link>
    <description>Recent content on VirtualDataSet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>APL 2.0</copyright>
    <lastBuildDate>Mon, 27 Nov 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://docs.virtdata.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Why VirtData?</title>
      <link>http://docs.virtdata.io/why_virtdata/why_virtdata/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/why_virtdata/why_virtdata/</guid>
      <description>If it is not real data, then what is the value of it? Virtual data is something that, when you need it, has no substitute.
To explain why, let us consider the trade-offs in some basic simulation and testing challenges and what they mean.
Speed Challenge: access large amounts of bulk data Actual Data - depends primarily on speed and efficiency of storage system - limited to size of storage system</description>
    </item>
    
    <item>
      <title>Virtual Data Set - User&#39;s Guide</title>
      <link>http://docs.virtdata.io/</link>
      <pubDate>Fri, 19 May 2017 21:52:39 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/</guid>
      <description>Please stand by while we bring the docs online&amp;hellip;
This book serves as the primary documentation for VirtualDataSet projects.
What is a Virtual DataSet? Virtual data can be described by a recipe. It can be created when you attempt to access it. Virtual Data is a lens into a set of data that may not exist yet, but which, once observed, is as tangible as stored data. Virtual data is what results when you apply a mapping function to a coordinate.</description>
    </item>
    
    <item>
      <title>Mapping Functions</title>
      <link>http://docs.virtdata.io/concepts/mapping_functions/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/concepts/mapping_functions/</guid>
      <description>VirtData provides more than just a set of libraries and APIs. The concepts are the starting point and foundation. The software tools are built directly from the concepts. Having a strong understanding of them will enable you to get the most out of virtual dataset.
Procedural Generation Procedural generation is a method of generating data by feeding a stream of random or pseudo-random data into an algorithm. Usually, procedural generation aims to produce content which appears original, not generated by an algorithm &amp;ndash; believably authentic by some standard.</description>
    </item>
    
    <item>
      <title>Function Graphs</title>
      <link>http://docs.virtdata.io/concepts/function_graphs/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/concepts/function_graphs/</guid>
      <description>This section should be useful to new users as well as experienced developers. Here, we explain how and why we use functions for building data mapping recipes. If you are planning to do so, this section is essential reading.
Mapping Functions A function represents a mapping between one set of values and another. Consider a basic example in which the function N(i) maps an input number to text form.</description>
    </item>
    
    <item>
      <title>Syntax Reference</title>
      <link>http://docs.virtdata.io/syntax/syntax_overview/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/syntax/syntax_overview/</guid>
      <description>This is a railroad schematic of the currently supported VirtData recipe syntax.
If this is your first time reading this guide, it is best to start at the top and read in order. Once you are familiar with the page, it can be used as a handy reference.
 Conventions In this documentation, CAPITALIZED := sections refer directly to a syntax type, for reference purposes. Other sections accompany the syntax diagrams, and are more explanatory in nature.</description>
    </item>
    
    <item>
      <title>Cardinality</title>
      <link>http://docs.virtdata.io/modeling_datasets/modeling_cardinality/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/modeling_datasets/modeling_cardinality/</guid>
      <description>Data Types and Values Given that our values are all bits on some level, there is no basic fixed size data type that has an unlimited range of values. Even the floating point types have finite range, although it is represented and handled differently than that of the whole number types.
Standard Types For a 64-bit data type, there are \( 64^2 \) different distinct values that can be represented.</description>
    </item>
    
    <item>
      <title>Set Relationships</title>
      <link>http://docs.virtdata.io/modeling_datasets/set_relationships/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/modeling_datasets/set_relationships/</guid>
      <description>This section will talk about how to model relative cardinality between different types of entities. Before reading this, you should already be familiar with data mapping and cardinality functions.
Suppose you have two different sets of things in your virtual dataset:
 #zoom:0.75 #direction:right #.data: fill=#FFFFFF visual=frame [entity type A| [&amp;lt;data&amp;gt; &amp;#34;foo&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;bar&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;baz&amp;#34;] ]    #zoom:0.75 #direction:right #.data: fill=#FFFFFF visual=frame [entity type B| [&amp;lt;data&amp;gt; &amp;#34;X&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;Y&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;Z&amp;#34;] ]   It may be the case that there is no association between elements of the first set to the second set, as illustrated above.</description>
    </item>
    
    <item>
      <title>Typography</title>
      <link>http://docs.virtdata.io/siteinfo/typography/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/siteinfo/typography/</guid>
      <description>This book includes some diagrams that are rendered
on the client side from various graphical markup systems.
This page lets you verify that you can read the glyph and diagrams correctly. If you do not see two of everything, then you will not be able to see some of the diagrams in the book. In that case, please report the issue.
In each of the rendering checks below, the dynamically rendered element is shown first, followed by a reference image.</description>
    </item>
    
    <item>
      <title>collections</title>
      <link>http://docs.virtdata.io/functions/funcref_collections/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/functions/funcref_collections/</guid>
      <description>HashedLineToStringList  long -&amp;gt; HashedLineToStringList(String: filename, int: minSize, int: maxSize) -&amp;gt; java.util.List  HashedLineToStringSet Return a pseudo-randomly created Set from the values in the specified file.
 long -&amp;gt; HashedLineToStringSet(String: filename, int: minSize, int: maxSize) -&amp;gt; java.util.Set  ex: HashedLineToStringSet(&#39;data/variable_words.txt&#39;,2,10) - Create a set of words sized between 2 and 10 elements   HashedLineToStringStringMap Create a String-String map from the specified file, ranging in size from 0 to the specified maximum.</description>
    </item>
    
    <item>
      <title>conversion</title>
      <link>http://docs.virtdata.io/functions/funcref_conversion/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/functions/funcref_conversion/</guid>
      <description>LongToByte Convert the input long value to a byte, with negative values masked away.
 long -&amp;gt; LongToByte() -&amp;gt; Byte  LongToShort Convert the input value from long to short.
 long -&amp;gt; LongToShort() -&amp;gt; Short  ModuloToBigDecimal Return a {@code BigDecimal} value as the result of modulo division with the specified divisor.
 long -&amp;gt; ModuloToBigDecimal() -&amp;gt; java.math.BigDecimal long -&amp;gt; ModuloToBigDecimal(long: modulo) -&amp;gt; java.math.BigDecimal  ModuloToBigInt Return a {@code BigInteger} value as the result of modulo division with the specified divisor.</description>
    </item>
    
    <item>
      <title>datetime</title>
      <link>http://docs.virtdata.io/functions/funcref_datetime/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/functions/funcref_datetime/</guid>
      <description>StartingEpochMillis This function sets the minimum long value to the equivalent unix epoch time in milliseconds. It simply adds the input value to this base value as determined by the provided time specifier. It wraps any overflow within this range as well.
 long -&amp;gt; StartingEpochMillis(String: baseTimeSpec) -&amp;gt; long  ex: StartingEpochMillis(&#39;2017-01-01 23:59:59&#39;) - add the millisecond epoch time of 2017-01-01 23:59:59 to all input values   ToDate Convert the input value to a {@code Date}</description>
    </item>
    
    <item>
      <title>diagnostics</title>
      <link>http://docs.virtdata.io/functions/funcref_diagnostics/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/functions/funcref_diagnostics/</guid>
      <description>Show Show diagnostic values for the thread-local variable map.
 Object -&amp;gt; Show() -&amp;gt; String  ex: Show() - Show all values in a json-like format  Object -&amp;gt; Show(String[]&amp;hellip;: names) -&amp;gt; String  ex: Show(&#39;foo&#39;) - Show only the &amp;lsquo;foo&amp;rsquo; value in a json-like format ex: Show(&#39;foo&#39;,&#39;bar&#39;) - Show the &amp;lsquo;foo&amp;rsquo; and &amp;lsquo;bar&amp;rsquo; values in a json-like format   ToLongFunction Adapts any compatible FunctionalInterface type to a LongFunction, for use with higher-order functions, when they require a LongFunction as an argument.</description>
    </item>
    
    <item>
      <title>distributions</title>
      <link>http://docs.virtdata.io/functions/funcref_distributions/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/functions/funcref_distributions/</guid>
      <description>Beta @see Wikipedia: Beta distribution
@see Commons JavaDoc: BetaDistribution
Generate samples according to the specified probability density.
The input value consists of a long between 0L and Long.MAX_VALUE. This value is scaled to the unit interval (0.0, 1.0) as an index into a sampling function. The method used is inverse cumulative density sampling.
Sampling Mode
The curve can be sampled in either map or hash mode. Map mode simply indexes into the probability curve in the order that it would appear on a density plot.</description>
    </item>
    
    <item>
      <title>general</title>
      <link>http://docs.virtdata.io/functions/funcref_general/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/functions/funcref_general/</guid>
      <description>Add Adds a value to the input.
 double -&amp;gt; Add(double: addend) -&amp;gt; double long -&amp;gt; Add(long: addend) -&amp;gt; int long -&amp;gt; Add(long: addend) -&amp;gt; long int -&amp;gt; Add(int: addend) -&amp;gt; int  ex: Add(23) - adds integer 23 to the input integer value   AddCycleRange Adds a cycle range to the input, producing an increasing sawtooth-like output.
 long -&amp;gt; AddCycleRange(long: maxValue) -&amp;gt; int long -&amp;gt; AddCycleRange(long: minValue, long: maxValue) -&amp;gt; int long -&amp;gt; AddCycleRange(long: maxValue) -&amp;gt; long long -&amp;gt; AddCycleRange(long: minValue, long: maxValue) -&amp;gt; long int -&amp;gt; AddCycleRange(int: maxValue) -&amp;gt; int int -&amp;gt; AddCycleRange(int: minValue, int: maxValue) -&amp;gt; int  AddHashRange Adds a pseudo-random value within the specified range to the input.</description>
    </item>
    
    <item>
      <title>premade</title>
      <link>http://docs.virtdata.io/functions/funcref_premade/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/functions/funcref_premade/</guid>
      <description>FirstNames Return a pseudo-randomly sampled first name from the last US census data on first names occurring more than 100 times. Both male and female names are combined in this function.
 long -&amp;gt; FirstNames() -&amp;gt; String  ex: FirstNames() - select a random first name based on the chance of seeing it in the census data  long -&amp;gt; FirstNames(String: modifier) -&amp;gt; String  ex: FirstNames(&#39;map&#39;) - select over the first names by probability as input varies from 1L to Long.</description>
    </item>
    
    <item>
      <title>state</title>
      <link>http://docs.virtdata.io/functions/funcref_state/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/functions/funcref_state/</guid>
      <description>Clear Clears the per-thread map which is used by the Expr function.
 long -&amp;gt; Clear() -&amp;gt; long  notes: Clear all named entries from the per-thread map. ex: Clear() - clear all thread-local variables  long -&amp;gt; Clear(String[]&amp;hellip;: names) -&amp;gt; long  notes: Clear the specified names from the per-thread map. ex: Clear(&#39;foo&#39;) - clear the thread-local variable &amp;lsquo;foo&amp;rsquo; ex: Clear(&#39;foo&#39;,&#39;bar&#39;) - clear the thread-local variables &amp;lsquo;foo&amp;rsquo; and &amp;lsquo;bar&amp;rsquo;   Load Load a named value from the per-thread state map.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/extending_virtdata/adding_libraries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/extending_virtdata/adding_libraries/</guid>
      <description>Adding a Data Mapper Library The basic recipe for adding a data mapper library to the VirtData runtime is a follows:
 Add maven dependency Implement DataMapperLibrary  If you are just wanting to provide functional classes implementing your mapping functions, simply extend &amp;hellip;  Implement your functions&amp;hellip; Add supporting documentation Add your Maven mojo to publish your library to the services manifest in META-INF/services/ Expose your library to the runtimes   In detail&amp;hellip;</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/extending_virtdata/extending_virtdata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/extending_virtdata/extending_virtdata/</guid>
      <description>Extending VirtData The VirtData library is not meant to be a closed system. Much of the runtime wiring was built to allow easy extension with data mapping functions of your own design. This is true at the module level as well as the individual function level.
The following sections should tell you everything you need to customize the avaialble data mapping functions for your own projects.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/extending_virtdata/library_structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/extending_virtdata/library_structure/</guid>
      <description>VirtData Library Structure The data mapping functions that come with the virtdata runtime are implemented and packaged as individual libraries. They come along for the ride with the runtime artifact.
Data Mapper Libraries Each such library is known as a data mapper library, and comes with its own essential machinery:
Library Metadata The metadata for a library describes the name and purpose of the library so that users may know when and why to use it.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/matter/glossary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/matter/glossary/</guid>
      <description>Glossary  Data Model  A model that describes the types of data that may be stored in a data set, logical or physical. It includes the types, and in some cases, the implied set of operations which are valid for accessing and manipulationg the data.  Dataset  A dataset is simply a named set of content which can be consumed, and/or modified, generally for a particular purpose. A dataset can be described by a generative model or it can be actual data that has been simulated or captured from a real world activity.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/nomnoml_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/nomnoml_test/</guid>
      <description>paragraph 1
{{#nomnoml #direction:right [f2| [ func2] [ arg2] &amp;ndash;&amp;gt; [func2] ] [ itype2] -&amp;gt; [f2] [ itype3] -&amp;gt; [f2] [f2] -&amp;gt; [ otype2] }}</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/</guid>
      <description> Coming Soon This book is a work in progress. This is an outline of upcoming sections.
 Using VirtData  Specifiers Common Recipes  Extending VirtData  Library Structure Adding a Library   - [Using VirtData](./using_virtdata/using_virtdata.md) - [Specifiers](./using_virtdata/specifiers.md) - [Common Recipes](./using_virtdata/common_recipes.md) - [Extending VirtData](./extending_virtdata/extending_virtdata.md) - [Library Structure](./extending_virtdata/library_structure.md) - [Adding a Library](./extending_virtdata/adding_libraries.md)  </description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/using_virtdata/common_recipes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/using_virtdata/common_recipes/</guid>
      <description> Common VirtData Recipes Identity Identity()  Random Values random longs Hash()  </description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/using_virtdata/specifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/using_virtdata/specifiers/</guid>
      <description>Metagen Design 101 This serves as a basic design doc for metagen, including library integration, specifier formats, etc.
Overview Metagen&amp;rsquo;s purpose is to make a modular and composable set of procedural generation libraries that everyone can use. A succesful outcome would resemble users building complex data mapping recipes in the same spirit of adding seasonings to their favorite soup recipe.
Eventually, a rapid-prototyping feedback loop similar to the REPL concept will be supported.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/using_virtdata/using_virtdata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/using_virtdata/using_virtdata/</guid>
      <description>VirtData Usage TBD: restructure the section Data Mapper Library Data Mapping functions are packaged into libraries which can be loaded by the user library module of the project. Each library has its own way of providing
Function Resolver Each library must implement its own function resolver. This is because each library may have a different way of naming, finding, creating or managing function generator instances. For the user, the description of a generator is simply a string.</description>
    </item>
    
  </channel>
</rss>